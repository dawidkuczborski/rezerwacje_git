import express from "express";
import cors from "cors";
import dotenv from "dotenv";
import admin from "firebase-admin";
import pkg from "pg";
import fs from "fs";
import path from "path";
import multer from "multer";        // âœ… DODAJ TO!
import { fileURLToPath } from "url";

dotenv.config();
const { Pool } = pkg;

// ðŸ”¹ Firebase Admin SDK
const serviceAccount = JSON.parse(
  fs.readFileSync("./serviceAccountKey.json", "utf8")
);

admin.initializeApp({
  credential: admin.credential.cert(serviceAccount),
});

// ðŸ”¹ PoÅ‚Ä…czenie z bazÄ… PostgreSQL (Render)
const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
  ssl: { rejectUnauthorized: false },
});

// ðŸ”¹ Express app
const app = express();
app.use(cors());
app.use(express.json());

// ðŸ”¹ ÅšcieÅ¼ki absolutne (Å¼eby dziaÅ‚aÅ‚o niezaleÅ¼nie od miejsca uruchomienia)
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// ðŸ”¹ Folder z obrazkami udostÄ™pniony publicznie
app.use("/uploads", express.static(path.join(__dirname, "uploads")));





// ------------------- SALONY -------------------
const salonStorage = multer.diskStorage({
  destination: (req, file, cb) => {
    const basePath = path.join("uploads", "salons");
    fs.mkdirSync(basePath, { recursive: true });
    cb(null, basePath);
  },
  filename: (req, file, cb) => {
    const ext = path.extname(file.originalname);
    const safeName = file.originalname.replace(/\s+/g, "_");
    cb(null, Date.now() + "_" + safeName);
  },
});
export const uploadSalonImage = multer({ storage: salonStorage });

// ------------------- USÅUGI -------------------
const serviceStorage = multer.diskStorage({
  destination: (req, file, cb) => {
    const salonId = req.body.salon_id || "unknown";
    const basePath = path.join("uploads", `salon_${salonId}`, "services");
    fs.mkdirSync(basePath, { recursive: true });
    cb(null, basePath);
  },
  filename: (req, file, cb) => {
    const ext = path.extname(file.originalname);
    const safeName = file.originalname.replace(/\s+/g, "_");
    cb(null, Date.now() + "_" + safeName);
  },
});
export const uploadServiceImage = multer({ storage: serviceStorage });

// ðŸ”¹ Folder gÅ‚Ã³wny z plikami udostÄ™pniony publicznie
app.use("/uploads", express.static(path.join(__dirname, "uploads")));


// ------------------- PRACOWNICY -------------------
const employeeStorage = multer.diskStorage({
  destination: (req, file, cb) => {
    const salonId = req.body.salon_id || "unknown";
    const basePath = path.join("uploads", `salon_${salonId}`, "employees");
    fs.mkdirSync(basePath, { recursive: true });
    cb(null, basePath);
  },
  filename: (req, file, cb) => {
    const ext = path.extname(file.originalname);
    const safeName = file.originalname.replace(/\s+/g, "_");
    cb(null, Date.now() + "_" + safeName);
  },
});
export const uploadEmployeeImage = multer({ storage: employeeStorage });




// ðŸ”¹ Tworzenie tabel (jeÅ›li nie istniejÄ…)
const initTables = async () => {
  await pool.query(`
    CREATE TABLE IF NOT EXISTS users (
      id SERIAL PRIMARY KEY,
      uid VARCHAR(255) UNIQUE NOT NULL,
      email VARCHAR(255) UNIQUE NOT NULL,
      name VARCHAR(255),
      role VARCHAR(50) DEFAULT 'client',
      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    );
  `);

await pool.query(`
  CREATE TABLE IF NOT EXISTS salons (
    id SERIAL PRIMARY KEY,
    owner_uid VARCHAR(255) REFERENCES users(uid) ON DELETE CASCADE,
    name VARCHAR(255) NOT NULL,
    city VARCHAR(100),
    street VARCHAR(100),
    street_number VARCHAR(20),
    postal_code VARCHAR(20),
    phone VARCHAR(50),
    description TEXT,
    image_url VARCHAR(255),   -- ðŸ”¹ Å›cieÅ¼ka do zdjÄ™cia
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
  );
`);

  // ðŸ”¹ Tabela pracownikÃ³w
await pool.query(`
  CREATE TABLE IF NOT EXISTS employees (
    id SERIAL PRIMARY KEY,
    salon_id INTEGER REFERENCES salons(id) ON DELETE CASCADE,
    uid VARCHAR(255) UNIQUE,
    name VARCHAR(255) NOT NULL,
    email VARCHAR(255) UNIQUE NOT NULL,
    phone VARCHAR(50),
    description TEXT,
    image_url VARCHAR(255), -- ðŸ”¹ dodane pole na zdjÄ™cie
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
  );
`);


  // ðŸ”¹ Tabela usÅ‚ug
await pool.query(`
  CREATE TABLE IF NOT EXISTS services (
    id SERIAL PRIMARY KEY,
    salon_id INTEGER REFERENCES salons(id) ON DELETE CASCADE,
    name VARCHAR(255) NOT NULL,
    duration_minutes INTEGER NOT NULL,
    price NUMERIC(10,2) NOT NULL,
    description TEXT,
    image_url VARCHAR(255), -- ðŸ”¹ nowe pole na zdjÄ™cie
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
  );
`);


  // ðŸ”¹ PowiÄ…zania usÅ‚ug z pracownikami
  await pool.query(`
    CREATE TABLE IF NOT EXISTS employee_services (
      id SERIAL PRIMARY KEY,
      employee_id INTEGER REFERENCES employees(id) ON DELETE CASCADE,
      service_id INTEGER REFERENCES services(id) ON DELETE CASCADE,
      UNIQUE (employee_id, service_id)
    );
  `);

  // ðŸ”¹ Harmonogram pracownikÃ³w (indywidualne godziny pracy)
  await pool.query(`
    CREATE TABLE IF NOT EXISTS employee_schedule (
      id SERIAL PRIMARY KEY,
      employee_id INTEGER REFERENCES employees(id) ON DELETE CASCADE,
      day_of_week INTEGER NOT NULL,         -- 0 = niedziela, 6 = sobota
      open_time TIME NOT NULL,
      close_time TIME NOT NULL,
      is_day_off BOOLEAN DEFAULT false,
      UNIQUE (employee_id, day_of_week)
    );
  `);

  // ðŸ”¹ ÅšwiÄ™ta i dni wolne salonu
  await pool.query(`
    CREATE TABLE IF NOT EXISTS salon_holidays (
      id SERIAL PRIMARY KEY,
      salon_id INTEGER REFERENCES salons(id) ON DELETE CASCADE,
      date DATE NOT NULL,
      reason VARCHAR(255),
      UNIQUE (salon_id, date)
    );
  `);

  // ðŸ”¹ rezerwacja
  await pool.query(`
	  CREATE TABLE IF NOT EXISTS appointments (
	  id SERIAL PRIMARY KEY,
	  salon_id INTEGER REFERENCES salons(id) ON DELETE CASCADE,
	  employee_id INTEGER REFERENCES employees(id) ON DELETE CASCADE,
	  client_uid VARCHAR(255) REFERENCES users(uid) ON DELETE SET NULL,
	  service_id INTEGER REFERENCES services(id) ON DELETE CASCADE,
	  date DATE NOT NULL,
	  start_time TIME NOT NULL,
	  end_time TIME NOT NULL,
	  status VARCHAR(50) DEFAULT 'booked', -- booked / cancelled / completed
	  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
	);
  `);
  
// ðŸ”¹ UsÅ‚ugi dodatkowe
await pool.query(`
  CREATE TABLE IF NOT EXISTS service_addons (
    id SERIAL PRIMARY KEY,
    salon_id INTEGER REFERENCES salons(id) ON DELETE CASCADE,
    name VARCHAR(255) NOT NULL,
    duration_minutes INTEGER NOT NULL,
    price NUMERIC(10,2) NOT NULL,
    description TEXT,
    is_active BOOLEAN DEFAULT true,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
  );
`);

// ðŸ”¹ PowiÄ…zania usÅ‚ug gÅ‚Ã³wnych z dodatkami (Nâ†”N)
await pool.query(`
  CREATE TABLE IF NOT EXISTS service_addon_links (
    id SERIAL PRIMARY KEY,
    service_id INTEGER REFERENCES services(id) ON DELETE CASCADE,
    addon_id INTEGER REFERENCES service_addons(id) ON DELETE CASCADE,
    UNIQUE (service_id, addon_id)
  );
`);
  // ðŸ”¹ PowiÄ…zanie rezerwacji z dodatkami (N:N)
  await pool.query(`
    CREATE TABLE IF NOT EXISTS appointment_addons (
      id SERIAL PRIMARY KEY,
      appointment_id INTEGER REFERENCES appointments(id) ON DELETE CASCADE,
      addon_id INTEGER REFERENCES service_addons(id) ON DELETE CASCADE,
      UNIQUE (appointment_id, addon_id)
    );
  `);

    // ðŸ”¹ Urlopy / nieobecnoÅ›ci pracownikÃ³w
  await pool.query(`
    CREATE TABLE IF NOT EXISTS employee_vacations (
      id SERIAL PRIMARY KEY,
      employee_id INTEGER REFERENCES employees(id) ON DELETE CASCADE,
      start_date DATE NOT NULL,
      end_date DATE NOT NULL,
      reason VARCHAR(255),
      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    );
  `);
  
  await pool.query(`
  CREATE TABLE IF NOT EXISTS categories (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) UNIQUE NOT NULL
  );
`);

await pool.query(`
  CREATE TABLE IF NOT EXISTS salon_categories (
    id SERIAL PRIMARY KEY,
    salon_id INTEGER REFERENCES salons(id) ON DELETE CASCADE,
    category_id INTEGER REFERENCES categories(id) ON DELETE CASCADE,
    UNIQUE (salon_id, category_id)
  );
`);

await pool.query(`
  INSERT INTO categories (name)
  VALUES 
    ('Fryzjer'),
    ('Barber'),
    ('Kosmetyczka'),
    ('Spa'),
    ('Manicure / Pedicure')
  ON CONFLICT (name) DO NOTHING;
`);


  console.log("âœ… Tables 'employee_schedule', 'salon_holidays', 'employee_vacations' ready");
};

// ðŸŸ¢ Uruchom inicjalizacjÄ™ tabel
initTables()
  .then(() => console.log("âœ… Wszystkie tabele zostaÅ‚y utworzone lub juÅ¼ istniejÄ…"))
  .catch((err) => console.error("âŒ BÅ‚Ä…d przy tworzeniu tabel:", err));



// ðŸ”¹ Middleware â€“ weryfikacja tokenu Firebase i pobranie uÅ¼ytkownika z bazy
const verifyToken = async (req, res, next) => {
  try {
    const authHeader = req.headers.authorization;
    if (!authHeader || !authHeader.startsWith("Bearer ")) {
      req.user = null;
      return next();
    }

    const token = authHeader.split(" ")[1];
    const decoded = await admin.auth().verifyIdToken(token);

    const userResult = await pool.query(
      "SELECT * FROM users WHERE uid = $1 LIMIT 1",
      [decoded.uid]
    );

    if (userResult.rows.length === 0) {
      req.user = { uid: decoded.uid, email: decoded.email, role: "guest" };
    } else {
      req.user = userResult.rows[0];
    }
    next();
  } catch (error) {
    console.error("verifyToken error:", error);
    req.user = null;
    next();
  }
};

// --- Middleware: tylko wÅ‚aÅ›ciciele mogÄ… zarzÄ…dzaÄ‡ salonami ---
function requireProviderRole(req, res, next) {
  if (!req.user || req.user.role !== "provider") {
    return res
      .status(403)
      .json({ error: "Tylko wÅ‚aÅ›ciciele salonÃ³w majÄ… dostÄ™p" });
  }
  next();
}

// --- Rejestracja uÅ¼ytkownika ---
app.post("/api/auth/register", verifyToken, async (req, res) => {
  const { email, name, role, phone } = req.body;
  const uid = req.user?.uid;

  if (!uid) return res.status(401).json({ error: "Brak UID uÅ¼ytkownika" });

  // ðŸ”¹ Walidacja numeru telefonu
  const phoneRegex = /^[0-9]{9}$/;
  if (!phoneRegex.test(phone)) {
    return res.status(400).json({ error: "Numer telefonu musi zawieraÄ‡ dokÅ‚adnie 9 cyfr" });
  }

  try {
    const existing = await pool.query("SELECT * FROM users WHERE uid = $1", [uid]);
    if (existing.rows.length > 0)
      return res.status(200).json({ message: "UÅ¼ytkownik juÅ¼ istnieje", user: existing.rows[0] });

    const result = await pool.query(
      `INSERT INTO users (uid, email, name, phone, role)
       VALUES ($1, $2, $3, $4, $5) RETURNING *`,
      [uid, email, name, phone, role || "client"]
    );

    res.status(201).json({ message: "âœ… UÅ¼ytkownik zarejestrowany", user: result.rows[0] });
  } catch (err) {
    console.error("âŒ BÅ‚Ä…d przy rejestracji:", err);
    res.status(500).json({ error: "BÅ‚Ä…d serwera przy rejestracji" });
  }
});



app.get("/api/auth/me", verifyToken, async (req, res) => {
  try {
    if (!req.user?.uid) return res.status(401).json({ error: "Brak uÅ¼ytkownika" });

    // ðŸ”¹ JeÅ›li uÅ¼ytkownik jest juÅ¼ w bazie â€” zwrÃ³Ä‡ go
    const result = await pool.query("SELECT * FROM users WHERE uid = $1", [req.user.uid]);
    if (result.rows.length > 0) {
      return res.json(result.rows[0]);
    }

    // ðŸ”¹ JeÅ›li nie ma w bazie â€” utwÃ³rz nowego uÅ¼ytkownika na podstawie Firebase
    const fbUser = await admin.auth().getUser(req.user.uid);

    const newUser = {
      uid: fbUser.uid,
      email: fbUser.email,
      name: fbUser.displayName || "UÅ¼ytkownik",
      role: "client",
    };

    // Opcjonalnie â€” moÅ¼esz dodaÄ‡ do bazy:
    await pool.query(
      "INSERT INTO users (uid, email, name, role) VALUES ($1, $2, $3, $4) ON CONFLICT DO NOTHING",
      [newUser.uid, newUser.email, newUser.name, newUser.role]
    );

    return res.json(newUser);
  } catch (err) {
    console.error("âŒ BÅ‚Ä…d przy pobieraniu uÅ¼ytkownika:", err);
    res.status(500).json({ error: "BÅ‚Ä…d serwera przy pobieraniu uÅ¼ytkownika" });
  }
});



// --- Tworzenie salonu z opcjonalnym zdjÄ™ciem ---
app.post("/api/salons", verifyToken, requireProviderRole, uploadSalonImage.single("image"), async (req, res) => {

  const { name, city, street, street_number, postal_code, phone, description } = req.body;
  const image_url = req.file ? req.file.filename : null;

  try {
    const result = await pool.query(
      `INSERT INTO salons
        (owner_uid, name, city, street, street_number, postal_code, phone, description, image_url, is_active)
       VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, true)
       RETURNING *`,
      [req.user.uid, name, city, street, street_number, postal_code, phone, description, image_url]
    );

    res.json({ message: "âœ… Salon utworzony", salon: result.rows[0] });
  } catch (err) {
    console.error("âŒ BÅ‚Ä…d przy tworzeniu salonu:", err);
    res.status(500).json({ error: "BÅ‚Ä…d przy tworzeniu salonu" });
  }
});


// --- Aktualizacja salonu ---
app.put("/api/salons/:id", verifyToken, requireProviderRole, uploadSalonImage.single("image"), async (req, res) => {

  const { id } = req.params;
  const { name, city, street, street_number, postal_code, phone, description } = req.body;
  const newImage = req.file ? req.file.filename : null;

  try {
    // ðŸ”¹ Pobierz istniejÄ…ce dane salonu, Å¼eby zachowaÄ‡ stare zdjÄ™cie jeÅ›li nie ma nowego
    const existing = await pool.query(
      "SELECT image_url FROM salons WHERE id=$1 AND owner_uid=$2",
      [id, req.user.uid]
    );

    if (existing.rows.length === 0) {
      return res.status(404).json({ error: "Salon nie znaleziony lub brak uprawnieÅ„" });
    }

    const currentImage = existing.rows[0].image_url;
    const finalImage = newImage || currentImage; // â† zostaw stare zdjÄ™cie jeÅ›li brak nowego

    // ðŸ”¹ Aktualizuj dane
    const updateQuery = `
      UPDATE salons SET
        name=$1, city=$2, street=$3, street_number=$4,
        postal_code=$5, phone=$6, description=$7, image_url=$8
      WHERE id=$9 AND owner_uid=$10
      RETURNING *;
    `;

    const result = await pool.query(updateQuery, [
      name,
      city,
      street,
      street_number,
      postal_code,
      phone,
      description,
      finalImage,
      id,
      req.user.uid,
    ]);

    if (result.rows.length === 0) {
      return res.status(404).json({ error: "Salon nie zostaÅ‚ znaleziony" });
    }

    res.json({ message: "Salon zaktualizowany pomyÅ›lnie", salon: result.rows[0] });
  } catch (err) {
    console.error("âŒ BÅ‚Ä…d przy edycji salonu:", err.message);
    res.status(500).json({ error: "BÅ‚Ä…d przy edycji salonu" });
  }
});




app.delete("/api/salons/:id", verifyToken, requireProviderRole, async (req, res) => {
  const { id } = req.params;
  try {
    const result = await pool.query(
      "DELETE FROM salons WHERE id=$1 AND owner_uid=$2 RETURNING id",
      [id, req.user.uid]
    );
    if (result.rows.length === 0)
      return res.status(404).json({ error: "Nie znaleziono salonu" });

    res.json({ message: "ðŸ—‘ï¸ Salon usuniÄ™ty" });
  } catch (err) {
    console.error("âŒ BÅ‚Ä…d przy usuwaniu salonu:", err);
    res.status(500).json({ error: "BÅ‚Ä…d przy usuwaniu salonu" });
  }
});




// --- Pobieranie salonu zalogowanego wÅ‚aÅ›ciciela ---
app.get("/api/salons/mine", verifyToken, requireProviderRole, async (req, res) => {
  try {
    const result = await pool.query("SELECT * FROM salons WHERE owner_uid = $1 LIMIT 1", [
      req.user.uid,
    ]);
    res.json(result.rows[0] || {});
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "BÅ‚Ä…d przy pobieraniu salonu" });
  }
});


// --- Zaproszenie pracownika z opcjonalnym zdjÄ™ciem ---
app.post(
  "/api/employees/invite",
  verifyToken,
  requireProviderRole,
  uploadEmployeeImage.single("image"), // ðŸ†• obsÅ‚uga pliku
  async (req, res) => {
    const { name, email, phone, description, password, salon_id } = req.body;
    const image_url = req.file
      ? `uploads/salon_${salon_id}/employees/${req.file.filename}`
      : null;

    if (!password || password.length < 6) {
      return res.status(400).json({ error: "HasÅ‚o musi mieÄ‡ co najmniej 6 znakÃ³w" });
    }
    if (!salon_id) {
      return res.status(400).json({ error: "Brak salon_id â€” wybierz salon" });
    }

    try {
      // ðŸ”¹ SprawdÅº, czy salon naleÅ¼y do zalogowanego wÅ‚aÅ›ciciela
      const salonCheck = await pool.query(
        `SELECT id FROM salons WHERE id = $1 AND owner_uid = $2`,
        [salon_id, req.user.uid]
      );
      if (salonCheck.rows.length === 0) {
        return res.status(403).json({ error: "Nie masz uprawnieÅ„ do tego salonu" });
      }

      // ðŸ”¹ UtwÃ³rz konto Firebase
      let userRecord;
      try {
        userRecord = await admin.auth().getUserByEmail(email);
        return res.status(400).json({ error: "UÅ¼ytkownik o tym e-mailu juÅ¼ istnieje" });
      } catch (err) {
        if (err.code === "auth/user-not-found") {
          userRecord = await admin.auth().createUser({
            email,
            password,
            displayName: name,
          });
        } else {
          throw err;
        }
      }

      // ðŸ”¹ Zapisz pracownika do bazy z obrazkiem
      const result = await pool.query(
        `INSERT INTO employees (salon_id, uid, name, email, phone, description, image_url, is_active)
         VALUES ($1, $2, $3, $4, $5, $6, $7, true)
         RETURNING *`,
        [salon_id, userRecord.uid, name, email, phone, description, image_url]
      );

      res.json({
        message: `âœ… Pracownik ${name} dodany do salonu #${salon_id}`,
        employee: result.rows[0],
      });
    } catch (err) {
      console.error("âŒ BÅ‚Ä…d przy tworzeniu pracownika:", err);
      res.status(500).json({ error: "BÅ‚Ä…d przy tworzeniu pracownika" });
    }
  }
);


// --- Edycja pracownika (z opcjonalnym nowym zdjÄ™ciem)
app.put(
  "/api/employees/:id",
  verifyToken,
  requireProviderRole,
  uploadEmployeeImage.single("image"),
  async (req, res) => {
    const { id } = req.params;
    const { name, phone, description, salon_id } = req.body;
    const newImage = req.file
      ? `uploads/salon_${salon_id}/employees/${req.file.filename}`
      : null;

    try {
      const empCheck = await pool.query(
        `SELECT e.id, e.image_url
         FROM employees e
         JOIN salons s ON e.salon_id = s.id
         WHERE e.id = $1 AND s.owner_uid = $2`,
        [id, req.user.uid]
      );

      if (empCheck.rows.length === 0) {
        return res.status(403).json({ error: "Brak uprawnieÅ„ do edycji pracownika" });
      }

      const currentImage = empCheck.rows[0].image_url;
      const finalImage = newImage || currentImage;

      const result = await pool.query(
        `UPDATE employees
         SET name=$1, phone=$2, description=$3, image_url=$4
         WHERE id=$5
         RETURNING *`,
        [name, phone, description, finalImage, id]
      );

      res.json({ message: "âœ… Pracownik zaktualizowany", employee: result.rows[0] });
    } catch (err) {
      console.error("âŒ BÅ‚Ä…d przy edycji pracownika:", err);
      res.status(500).json({ error: "BÅ‚Ä…d przy edycji pracownika" });
    }
  }
);











// --- Tworzenie nowej usÅ‚ugi (tylko wÅ‚aÅ›ciciel) ---
app.post(
  "/api/services",
  verifyToken,
  requireProviderRole,
  uploadServiceImage.single("image"),
  async (req, res) => {
    try {
      // ðŸ”¹ multer wypeÅ‚ni req.body, wiÄ™c moÅ¼emy odczytaÄ‡ pola
      const { name, duration_minutes, price, description, salon_id } = req.body;
      const image_url = req.file
  ? `uploads/salon_${salon_id}/services/${req.file.filename}`
  : null;


      if (!salon_id || !name || !price) {
        return res.status(400).json({ error: "Brak wymaganych danych" });
      }

      // ðŸ”¹ SprawdÅº, czy salon naleÅ¼y do zalogowanego wÅ‚aÅ›ciciela
      const salonCheck = await pool.query(
        "SELECT id FROM salons WHERE id = $1 AND owner_uid = $2",
        [salon_id, req.user.uid]
      );

      if (salonCheck.rows.length === 0) {
        return res
          .status(403)
          .json({ error: "Nie masz uprawnieÅ„ do tego salonu" });
      }

      // ðŸ”¹ Zapisz usÅ‚ugÄ™ do bazy
      const result = await pool.query(
        `INSERT INTO services (salon_id, name, duration_minutes, price, description, image_url)
         VALUES ($1, $2, $3, $4, $5, $6)
         RETURNING *`,
        [salon_id, name, duration_minutes, price, description, image_url]
      );

      res.json({ message: "ðŸ’‡â€â™‚ï¸ UsÅ‚uga dodana", service: result.rows[0] });
    } catch (err) {
      console.error("âŒ BÅ‚Ä…d przy dodawaniu usÅ‚ugi:", err);
      res.status(500).json({ error: "BÅ‚Ä…d przy dodawaniu usÅ‚ugi" });
    }
  }
);


// --- Edycja usÅ‚ugi z moÅ¼liwoÅ›ciÄ… zmiany zdjÄ™cia ---
app.put(
  "/api/services/:id",
  verifyToken,
  requireProviderRole,
  uploadServiceImage.single("image"),
  async (req, res) => {
    const { id } = req.params;
    const { name, duration_minutes, price, description, salon_id } = req.body;
    const newImage = req.file
      ? path.join(`salon_${salon_id}`, "services", req.file.filename)
      : null;

    try {
      // ðŸ”¹ SprawdÅº, czy usÅ‚uga naleÅ¼y do salonu wÅ‚aÅ›ciciela
      const serviceCheck = await pool.query(
        `SELECT s.id, s.image_url
         FROM services s
         JOIN salons sa ON s.salon_id = sa.id
         WHERE s.id = $1 AND sa.owner_uid = $2`,
        [id, req.user.uid]
      );

      if (serviceCheck.rows.length === 0) {
        return res
          .status(403)
          .json({ error: "Brak uprawnieÅ„ do edycji tej usÅ‚ugi" });
      }

      const currentImage = serviceCheck.rows[0].image_url;
      const finalImage = newImage || currentImage;

      // ðŸ”¹ Aktualizuj dane usÅ‚ugi
      const result = await pool.query(
        `UPDATE services
         SET name = $1,
             duration_minutes = $2,
             price = $3,
             description = $4,
             image_url = $5
         WHERE id = $6
         RETURNING *`,
        [name, duration_minutes, price, description, finalImage, id]
      );

      res.json({ message: "âœ… UsÅ‚uga zaktualizowana", service: result.rows[0] });
    } catch (err) {
      console.error("âŒ BÅ‚Ä…d edycji usÅ‚ugi:", err);
      res.status(500).json({ error: "BÅ‚Ä…d przy edycji usÅ‚ugi" });
    }
  }
);




// --- Pobieranie usÅ‚ug danego salonu (dla wÅ‚aÅ›ciciela) ---
app.get("/api/services/mine", verifyToken, requireProviderRole, async (req, res) => {
  try {
    const { salon_id } = req.query;

    if (!salon_id) {
      return res.status(400).json({ error: "Brak salon_id w zapytaniu" });
    }

    // ðŸ”¹ SprawdÅº, czy salon naleÅ¼y do zalogowanego wÅ‚aÅ›ciciela
    const salonCheck = await pool.query(
      "SELECT id FROM salons WHERE id = $1 AND owner_uid = $2",
      [salon_id, req.user.uid]
    );

    if (salonCheck.rows.length === 0) {
      return res.status(403).json({ error: "Nie masz dostÄ™pu do tego salonu" });
    }

    // ðŸ”¹ Pobierz usÅ‚ugi tego salonu
  const result = await pool.query(
  `SELECT id, name, duration_minutes, price, description, image_url, is_active, created_at
   FROM services
   WHERE salon_id = $1
   ORDER BY created_at DESC`,
  [salon_id]
);

    res.json(result.rows);
  } catch (err) {
    console.error("âŒ BÅ‚Ä…d przy pobieraniu usÅ‚ug salonu:", err);
    res.status(500).json({ error: "BÅ‚Ä…d przy pobieraniu usÅ‚ug salonu" });
  }
});



// --- Przypisywanie usÅ‚ugi do pracownika (tylko wÅ‚aÅ›ciciel) ---
app.post("/api/employee-services", verifyToken, requireProviderRole, async (req, res) => {
  const { employee_id, service_id } = req.body;

  try {
    await pool.query(
      `INSERT INTO employee_services (employee_id, service_id)
       VALUES ($1, $2)
       ON CONFLICT (employee_id, service_id) DO NOTHING`,
      [employee_id, service_id]
    );

    res.json({ message: "âœ… UsÅ‚uga przypisana do pracownika" });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: "BÅ‚Ä…d przy przypisywaniu usÅ‚ugi" });
  }
});

// --- Pobranie przypisaÅ„ usÅ‚ug do pracownikÃ³w konkretnego salonu ---
app.get("/api/employee-services", verifyToken, requireProviderRole, async (req, res) => {
  try {
    const { salon_id } = req.query;

    if (!salon_id) {
      return res.status(400).json({ error: "Brak salon_id w zapytaniu" });
    }

    // ðŸ”¹ SprawdÅº, czy salon naleÅ¼y do zalogowanego wÅ‚aÅ›ciciela
    const salonCheck = await pool.query(
      "SELECT id FROM salons WHERE id = $1 AND owner_uid = $2",
      [salon_id, req.user.uid]
    );

    if (salonCheck.rows.length === 0) {
      return res.status(403).json({ error: "Nie masz dostÄ™pu do tego salonu" });
    }

    // ðŸ”¹ Pobierz przypisania tylko z tego salonu
    const result = await pool.query(
      `SELECT e.id AS employee_id, e.name AS employee_name, e.email,
              s.id AS service_id, s.name AS service_name
       FROM employees e
       LEFT JOIN employee_services es ON e.id = es.employee_id
       LEFT JOIN services s ON es.service_id = s.id
       WHERE e.salon_id = $1
       ORDER BY e.id, s.id;`,
      [salon_id]
    );

    res.json(result.rows);
  } catch (err) {
    console.error("âŒ BÅ‚Ä…d przy pobieraniu przypisaÅ„ usÅ‚ug:", err);
    res.status(500).json({ error: "BÅ‚Ä…d przy pobieraniu przypisaÅ„ usÅ‚ug" });
  }
});



// --- PrzeÅ‚Ä…czanie przypisania usÅ‚ugi (checkbox) ---
app.post("/api/employee-services/toggle", verifyToken, requireProviderRole, async (req, res) => {
  const { employee_id, service_id, assigned } = req.body;

  try {
    if (assigned) {
      await pool.query(
        `INSERT INTO employee_services (employee_id, service_id)
         VALUES ($1, $2)
         ON CONFLICT DO NOTHING`,
        [employee_id, service_id]
      );
    } else {
      await pool.query(
        `DELETE FROM employee_services WHERE employee_id = $1 AND service_id = $2`,
        [employee_id, service_id]
      );
    }

    res.json({ message: "âœ… Zaktualizowano przypisanie" });
  } catch (err) {
    console.error("âŒ BÅ‚Ä…d aktualizacji przypisania:", err);
    res.status(500).json({ error: "BÅ‚Ä…d przy aktualizacji przypisania" });
  }
});

// --- Pobierz harmonogram danego pracownika ---
app.get("/api/schedule/employee/:employeeId", verifyToken, requireProviderRole, async (req, res) => {
  const { employeeId } = req.params;
  try {
    const result = await pool.query(
      `SELECT * FROM employee_schedule 
       WHERE employee_id = $1
       ORDER BY day_of_week`,
      [employeeId]
    );
    res.json(result.rows);
  } catch (err) {
    console.error("âŒ BÅ‚Ä…d pobierania harmonogramu:", err);
    res.status(500).json({ error: "BÅ‚Ä…d serwera" });
  }
});

// --- Zapis harmonogramu danego pracownika ---
app.post("/api/schedule/employee/:employeeId", verifyToken, requireProviderRole, async (req, res) => {
  const { employeeId } = req.params;
  const { schedule } = req.body;

  try {
    await pool.query("DELETE FROM employee_schedule WHERE employee_id = $1", [employeeId]);
    for (const d of schedule) {
      await pool.query(
        `INSERT INTO employee_schedule (employee_id, day_of_week, open_time, close_time, is_day_off)
         VALUES ($1, $2, $3, $4, $5)`,
        [employeeId, d.day_of_week, d.open_time, d.close_time, d.is_day_off]
      );
    }

    res.json({ message: "âœ… Harmonogram zapisany dla pracownika" });
  } catch (err) {
    console.error("âŒ BÅ‚Ä…d zapisu harmonogramu pracownika:", err);
    res.status(500).json({ error: "BÅ‚Ä…d zapisu harmonogramu" });
  }
});




// --- Pobierz Å›wiÄ™ta salonu ---
app.get("/api/schedule/holidays", verifyToken, requireProviderRole, async (req, res) => {
  try {
    const salon = await pool.query("SELECT id FROM salons WHERE owner_uid = $1 LIMIT 1", [req.user.uid]);
    if (salon.rows.length === 0) return res.status(400).json({ error: "Nie znaleziono salonu" });

    const salonId = salon.rows[0].id;
    const result = await pool.query("SELECT * FROM salon_holidays WHERE salon_id = $1 ORDER BY date", [salonId]);
    res.json(result.rows);
  } catch (err) {
    console.error("âŒ BÅ‚Ä…d pobierania dni wolnych:", err);
    res.status(500).json({ error: "BÅ‚Ä…d przy pobieraniu dni wolnych" });
  }
});

// --- Dodaj lub usuÅ„ dzieÅ„ wolny ---
app.post("/api/schedule/holidays", verifyToken, requireProviderRole, async (req, res) => {
  const { date, reason } = req.body;
  try {
    const salon = await pool.query("SELECT id FROM salons WHERE owner_uid = $1 LIMIT 1", [req.user.uid]);
    const salonId = salon.rows[0].id;

    await pool.query(
      `INSERT INTO salon_holidays (salon_id, date, reason)
       VALUES ($1, $2, $3)
       ON CONFLICT (salon_id, date) DO UPDATE SET reason = EXCLUDED.reason`,
      [salonId, date, reason]
    );

    res.json({ message: "âœ… DzieÅ„ wolny dodany" });
  } catch (err) {
    console.error("âŒ BÅ‚Ä…d przy dodawaniu dnia wolnego:", err);
    res.status(500).json({ error: "BÅ‚Ä…d przy dodawaniu dnia wolnego" });
  }
});


// --- Pobierz urlopy pracownikÃ³w ---
app.get("/api/schedule/vacations", verifyToken, requireProviderRole, async (req, res) => {
  try {
   const { salon_id } = req.body;

const salonCheck = await pool.query(
  "SELECT id FROM salons WHERE id = $1 AND owner_uid = $2",
  [salon_id, req.user.uid]
);

if (salonCheck.rows.length === 0) {
  return res.status(403).json({ error: "Nie masz uprawnieÅ„ do tego salonu" });
}


    const result = await pool.query(`
      SELECT e.name AS employee_name, v.*
      FROM employee_vacations v
      JOIN employees e ON v.employee_id = e.id
      WHERE e.salon_id = $1
      ORDER BY start_date;
    `, [salonId]);

    res.json(result.rows);
  } catch (err) {
    console.error("âŒ BÅ‚Ä…d przy pobieraniu urlopÃ³w:", err);
    res.status(500).json({ error: "BÅ‚Ä…d przy pobieraniu urlopÃ³w" });
  }
});

// --- Dodaj urlop pracownika ---
app.post("/api/schedule/vacations", verifyToken, requireProviderRole, async (req, res) => {
  const { employee_id, start_date, end_date, reason } = req.body;
  try {
    await pool.query(
      `INSERT INTO employee_vacations (employee_id, start_date, end_date, reason)
       VALUES ($1, $2, $3, $4)`,
      [employee_id, start_date, end_date, reason]
    );

    res.json({ message: "âœ… Urlop dodany" });
  } catch (err) {
    console.error("âŒ BÅ‚Ä…d przy dodawaniu urlopu:", err);
    res.status(500).json({ error: "BÅ‚Ä…d przy dodawaniu urlopu" });
  }
});




// --- Pobierz wszystkie usÅ‚ugi przypisane do danego pracownika ---
app.get("/api/services/by-employee/:employeeId", verifyToken, async (req, res) => {
  try {
    const { employeeId } = req.params;

    if (!employeeId) {
      return res.status(400).json({ error: "Brak parametru employeeId" });
    }

    // ðŸ”¹ pobierz wszystkie ID usÅ‚ug przypisanych do pracownika
    const rel = await pool.query(
      `SELECT service_id FROM employee_services WHERE employee_id = $1`,
      [employeeId]
    );

    if (!rel.rows.length) {
      return res.json([]); // brak usÅ‚ug
    }

    const serviceIds = rel.rows.map(r => r.service_id);

    // ðŸ”¹ pobierz szczegÃ³Å‚y usÅ‚ug
    const services = await pool.query(
      `SELECT id, name, price, duration_minutes
       FROM services
       WHERE id = ANY($1::int[])`,
      [serviceIds]
    );

    res.json(services.rows);
  } catch (err) {
    console.error("âŒ BÅ‚Ä…d przy pobieraniu usÅ‚ug pracownika:", err);
    res.status(500).json({ error: "BÅ‚Ä…d serwera przy pobieraniu usÅ‚ug pracownika" });
  }
});








// --- Pobierz dostÄ™pne terminy (sloty) dla danego dnia i usÅ‚ugi ---
app.get("/api/appointments/available", verifyToken, async (req, res) => {
  try {
    const { employee_id: employeeIdRaw, service_id, date } = req.query;
    let { addons, total_duration } = req.query;

    console.log("ðŸ§­ /available â†’ zapytanie:", req.query);

    if (!service_id || service_id === "undefined" || !date) {
      console.warn("âš ï¸ Brak service_id lub date â€“ zwracam pustÄ… listÄ™ slotÃ³w:", req.query);
      return res.json([]);
    }

    const employee_id =
      employeeIdRaw && !isNaN(Number(employeeIdRaw))
        ? Number(employeeIdRaw)
        : null;

    /* ---------------------------------------------
     * ðŸ§© Poprawna interpretacja addons z query
     * Express przyjmuje addons[0]=1&addons[1]=2 jako { '0': '1', '1': '2' }
     * --------------------------------------------- */
    let addonIds = [];
    if (addons) {
      if (typeof addons === "object" && !Array.isArray(addons)) {
        addonIds = Object.values(addons).map(Number);
      } else if (Array.isArray(addons)) {
        addonIds = addons.map(Number);
      } else {
        addonIds = [Number(addons)];
      }
      addonIds = addonIds.filter((n) => Number.isFinite(n) && n > 0);
    }

    console.log("ðŸ§© Slots query params:", {
      employee_id,
      service_id,
      date,
      addonIds,
      total_duration,
    });

    const targetDate = new Date(date);
    const dayOfWeek = targetDate.getUTCDay(); // 0 = niedziela, 6 = sobota

    // ðŸ”¹ Pobierz bazowÄ… dÅ‚ugoÅ›Ä‡ usÅ‚ugi z bazy
    const serviceRes = await pool.query(
      `SELECT duration_minutes FROM services WHERE id=$1`,
      [service_id]
    );
    let duration = Number(serviceRes.rows[0]?.duration_minutes || 0);

    // ðŸ”¹ JeÅ¼eli podano dodatki â€“ dolicz ich czasy
    if (addonIds.length > 0) {
      const addonQuery = await pool.query(
        `SELECT COALESCE(SUM(duration_minutes), 0) AS total
         FROM service_addons WHERE id = ANY($1::int[])`,
        [addonIds]
      );
      const extra = Number(addonQuery.rows[0]?.total || 0);
      duration += extra;
      console.log(`âž• Dodatki (${addonIds.length}) dodajÄ… ${extra} min â†’ razem ${duration} min`);
    }

    // ðŸ”¹ JeÅ›li frontend przesÅ‚aÅ‚ total_duration â€” nadpisz
    if (total_duration) {
      const totalFromClient = Number(total_duration);
      if (!isNaN(totalFromClient) && totalFromClient > 0) {
        console.log("ðŸ•’ Nadpisano dÅ‚ugoÅ›Ä‡ usÅ‚ugi przez frontend:", totalFromClient, "min");
        duration = totalFromClient;
      }
    }

    // ðŸ”¹ Pobierz pracownikÃ³w przypisanych do usÅ‚ugi
    let employees = [];
    if (employee_id) {
      const empRes = await pool.query("SELECT id, name FROM employees WHERE id = $1", [employee_id]);
      if (!empRes.rows.length)
        return res.status(404).json({ error: "Nie znaleziono pracownika" });
      employees = empRes.rows;
    } else {
      const empRes = await pool.query(
        `SELECT e.id, e.name
         FROM employees e
         JOIN employee_services es ON es.employee_id = e.id
         WHERE es.service_id = $1 AND e.is_active = true`,
        [service_id]
      );
      if (!empRes.rows.length)
        return res.status(404).json({ error: "Brak pracownikÃ³w wykonujÄ…cych tÄ™ usÅ‚ugÄ™" });
      employees = empRes.rows;
    }

    // ðŸ”¹ SprawdÅº Å›wiÄ™ta salonu
    const salonRes = await pool.query(
      `SELECT DISTINCT s.id
       FROM salons s
       JOIN employees e ON e.salon_id = s.id
       WHERE e.id = $1 LIMIT 1`,
      [employee_id || employees[0].id]
    );

    const salonId = salonRes.rows[0]?.id;
    if (salonId) {
      const hol = await pool.query(
        "SELECT 1 FROM salon_holidays WHERE salon_id = $1 AND date = $2",
        [salonId, date]
      );
      if (hol.rows.length > 0) {
        console.log("ðŸ–ï¸ Salon ma dzieÅ„ wolny:", date);
        return res.json([]);
      }
    }

    const results = [];

    // ðŸ” Generowanie slotÃ³w dla kaÅ¼dego pracownika
    for (const emp of employees) {
      const scheduleRes = await pool.query(
        `SELECT open_time, close_time, is_day_off
         FROM employee_schedule
         WHERE employee_id = $1 AND day_of_week = $2`,
        [emp.id, dayOfWeek]
      );

      if (!scheduleRes.rows.length || scheduleRes.rows[0].is_day_off) continue;

      const { open_time, close_time } = scheduleRes.rows[0];
      const [openH, openM] = open_time.split(":").map(Number);
      const [closeH, closeM] = close_time.split(":").map(Number);

      const start = new Date(`${date}T${openH.toString().padStart(2, "0")}:${openM.toString().padStart(2, "0")}:00`);
      const end = new Date(`${date}T${closeH.toString().padStart(2, "0")}:${closeM.toString().padStart(2, "0")}:00`);

      // ðŸ”¹ Urlopy
      const vacRes = await pool.query(
        `SELECT 1 FROM employee_vacations
         WHERE employee_id = $1
         AND $2::date BETWEEN start_date AND end_date`,
        [emp.id, date]
      );
      if (vacRes.rows.length > 0) continue;

      // ðŸ”¹ IstniejÄ…ce rezerwacje
      const appRes = await pool.query(
        `SELECT start_time, end_time FROM appointments
         WHERE employee_id = $1 AND date = $2 AND status = 'booked'`,
        [emp.id, date]
      );
      const booked = appRes.rows.map(a => ({
        start: new Date(`${date}T${a.start_time}`),
        end: new Date(`${date}T${a.end_time}`),
      }));

      // ðŸ”¹ Generowanie slotÃ³w â€” peÅ‚na dÅ‚ugoÅ›Ä‡ usÅ‚ugi + dodatki
      let current = new Date(start);

      while (current < end) {
        const serviceEnd = new Date(current.getTime() + duration * 60000);
        if (serviceEnd > end) break;

        const overlap = booked.some(
          (b) => current < b.end && serviceEnd > b.start
        );

        if (!overlap) {
          results.push({
            employee_id: emp.id,
            employee_name: emp.name,
            start_time: current.toTimeString().slice(0, 5),
            end_time: serviceEnd.toTimeString().slice(0, 5),
          });

          current = new Date(serviceEnd.getTime());
        } else {
          const nextFree = booked
            .filter((b) => b.end > current)
            .sort((a, b) => a.end - b.end)[0];

          current = nextFree
            ? new Date(nextFree.end.getTime())
            : new Date(serviceEnd.getTime());
        }
      }
    }

    // ðŸ”¹ Sortowanie wynikÃ³w
    results.sort((a, b) => {
      if (a.start_time === b.start_time) return a.employee_id - b.employee_id;
      return a.start_time.localeCompare(b.start_time);
    });

    console.log("ðŸŸ¢ Available slots:", results.slice(0, 10));
    res.json(results);
  } catch (err) {
    console.error("âŒ BÅ‚Ä…d przy pobieraniu dostÄ™pnych terminÃ³w:", err);
    res.status(500).json({ error: "BÅ‚Ä…d serwera przy generowaniu slotÃ³w" });
  }
});




// --- Tworzenie rezerwacji ---
app.post("/api/appointments", verifyToken, async (req, res) => {
  try {
    const { employee_id, service_id, date, start_time, end_time, addons = [] } = req.body;
    const client_uid = req.user?.uid;

    if (!client_uid) return res.status(401).json({ error: "Brak autoryzacji" });
    if (!employee_id || !service_id || !date || !start_time || !end_time)
      return res.status(400).json({ error: "Brak wymaganych danych" });

    // ðŸ”¹ SprawdÅº, czy klient nie ma juÅ¼ zarezerwowanej TEJ SAMEJ usÅ‚ugi w tym dniu
const existing = await pool.query(
  `SELECT 1 FROM appointments 
   WHERE client_uid = $1 
   AND date = $2 
   AND service_id = $3 
   AND status = 'booked'`,
  [client_uid, date, service_id]
);

if (existing.rows.length > 0) {
  return res.status(400).json({ error: "Masz juÅ¼ zarezerwowanÄ… tÄ™ usÅ‚ugÄ™ w tym dniu" });
}

    // ðŸ”¹ SprawdÅº, czy termin jest wolny (pomijajÄ…c anulowane)
    const conflict = await pool.query(
      `SELECT 1 FROM appointments
       WHERE employee_id = $1
       AND date = $2
       AND status = 'booked'
       AND ( (start_time, end_time) OVERLAPS ($3::time, $4::time) )`,
      [employee_id, date, start_time, end_time]
    );

    if (conflict.rows.length > 0) {
      return res.status(400).json({ error: "Ten termin jest juÅ¼ zajÄ™ty" });
    }

    // ðŸ”¹ Pobierz salon pracownika (dla spÃ³jnoÅ›ci danych)
    const salonRes = await pool.query(
      `SELECT salon_id FROM employees WHERE id = $1`,
      [employee_id]
    );
    if (!salonRes.rows.length)
      return res.status(404).json({ error: "Nie znaleziono pracownika" });
    const salon_id = salonRes.rows[0].salon_id;

    // ðŸ”¹ UtwÃ³rz rezerwacjÄ™
    const result = await pool.query(
      `INSERT INTO appointments 
        (salon_id, employee_id, client_uid, service_id, date, start_time, end_time, status)
       VALUES ($1, $2, $3, $4, $5, $6, $7, 'booked')
       RETURNING id`,
      [salon_id, employee_id, client_uid, service_id, date, start_time, end_time]
    );

    const appointmentId = result.rows[0].id;

    // ðŸ”¹ JeÅ›li wybrano dodatki, zapisz je
    if (addons.length > 0) {
      for (const addonId of addons) {
        await pool.query(
          `INSERT INTO appointment_addons (appointment_id, addon_id)
           VALUES ($1, $2) ON CONFLICT DO NOTHING`,
          [appointmentId, addonId]
        );
      }
    }

    res.json({ message: "âœ… Rezerwacja utworzona", appointment_id: appointmentId });
  } catch (err) {
    console.error("âŒ BÅ‚Ä…d przy tworzeniu rezerwacji:", err);
    res.status(500).json({ error: "BÅ‚Ä…d serwera przy tworzeniu rezerwacji" });
  }
});


// --- Pobierz rezerwacje zalogowanego klienta ---
app.get("/api/appointments/mine", verifyToken, async (req, res) => {
  try {
    if (!req.user?.uid)
      return res.status(401).json({ error: "Brak autoryzacji" });

    const result = await pool.query(
      `
      SELECT 
        a.*, 
        s.name AS service_name, 
        s.price AS service_price, 
        e.name AS employee_name,
        COALESCE(
          json_agg(
            json_build_object(
              'addon_id', sa.id,
              'addon_name', sa.name,
              'addon_price', sa.price,
              'addon_duration', sa.duration_minutes
            )
          ) FILTER (WHERE sa.id IS NOT NULL),
          '[]'
        ) AS addons
      FROM appointments a
      JOIN services s ON a.service_id = s.id
      JOIN employees e ON a.employee_id = e.id
      LEFT JOIN appointment_addons aa ON aa.appointment_id = a.id
      LEFT JOIN service_addons sa ON aa.addon_id = sa.id
      WHERE a.client_uid = $1
      GROUP BY a.id, s.name, s.price, e.name
      ORDER BY a.date DESC, a.start_time DESC;
      `,
      [req.user.uid]
    );

    res.json(result.rows);
  } catch (err) {
    console.error("âŒ BÅ‚Ä…d przy pobieraniu rezerwacji:", err);
    res.status(500).json({ error: "BÅ‚Ä…d przy pobieraniu rezerwacji" });
  }
});



// --- Lista pracownikÃ³w danego salonu ---
app.get("/api/employees/mine", verifyToken, requireProviderRole, async (req, res) => {
  try {
    const { salon_id } = req.query;

    if (!salon_id) {
      return res.status(400).json({ error: "Brak salon_id w zapytaniu" });
    }

    const salonCheck = await pool.query(
      "SELECT id FROM salons WHERE id = $1 AND owner_uid = $2",
      [salon_id, req.user.uid]
    );

    if (salonCheck.rows.length === 0) {
      return res.status(403).json({ error: "Nie masz dostÄ™pu do tego salonu" });
    }

    // ðŸ”¹ TUTAJ popraw SELECT:
    const result = await pool.query(
      `SELECT id, name, email, phone, description, image_url, is_active, created_at
       FROM employees
       WHERE salon_id = $1
       ORDER BY created_at DESC`,
      [salon_id]
    );

    res.json(result.rows);
  } catch (err) {
    console.error("âŒ BÅ‚Ä…d przy pobieraniu pracownikÃ³w:", err);
    res.status(500).json({ error: "BÅ‚Ä…d przy pobieraniu listy pracownikÃ³w" });
  }
});




// --- UsÅ‚ugi dostÄ™pne dla klientÃ³w ---
app.get("/api/services/public", verifyToken, async (req, res) => {
  try {
    const result = await pool.query("SELECT * FROM services WHERE is_active = true ORDER BY name");
    res.json(result.rows);
  } catch (err) {
    console.error("âŒ BÅ‚Ä…d pobierania usÅ‚ug publicznych:", err);
    res.status(500).json({ error: "BÅ‚Ä…d pobierania usÅ‚ug" });
  }
});

// --- Pracownicy dostÄ™pni dla klientÃ³w ---
app.get("/api/employees/public", verifyToken, async (req, res) => {
  try {
    const result = await pool.query(
      "SELECT id, name, description FROM employees WHERE is_active = true ORDER BY name"
    );
    res.json(result.rows);
  } catch (err) {
    console.error("âŒ BÅ‚Ä…d pobierania pracownikÃ³w publicznych:", err);
    res.status(500).json({ error: "BÅ‚Ä…d pobierania pracownikÃ³w" });
  }
});

// --- Pracownicy przypisani do konkretnej usÅ‚ugi (dla klienta) ---
app.get("/api/employees/by-service/:serviceId", async (req, res) => {
  const { serviceId } = req.params;

  try {
    const result = await pool.query(
      `
      SELECT 
        e.id, 
        e.name, 
        e.description, 
        e.image_url  -- ðŸ‘ˆ tu dodane zdjÄ™cie!
      FROM employees e
      JOIN employee_services es ON es.employee_id = e.id
      WHERE es.service_id = $1 AND e.is_active = true
      ORDER BY e.name;
      `,
      [serviceId]
    );

    res.json(result.rows);
  } catch (err) {
    console.error("âŒ BÅ‚Ä…d przy pobieraniu pracownikÃ³w dla usÅ‚ugi:", err);
    res.status(500).json({ error: "BÅ‚Ä…d przy pobieraniu pracownikÃ³w dla tej usÅ‚ugi" });
  }
});


// --- Dodawanie nowej usÅ‚ugi dodatkowej (tylko wÅ‚aÅ›ciciel) ---
app.post("/api/service-addons", verifyToken, requireProviderRole, async (req, res) => {
  const { name, duration_minutes, price, description, service_ids, salon_id } = req.body;

  try {
    // ðŸ”¹ SprawdÅº, czy salon istnieje i naleÅ¼y do wÅ‚aÅ›ciciela
    const salonCheck = await pool.query(
      "SELECT id FROM salons WHERE id = $1 AND owner_uid = $2",
      [salon_id, req.user.uid]
    );

    if (salonCheck.rows.length === 0) {
      return res.status(403).json({ error: "Nie masz uprawnieÅ„ do tego salonu" });
    }

    // ðŸ”¹ UtwÃ³rz dodatek
    const addonRes = await pool.query(
      `INSERT INTO service_addons (salon_id, name, duration_minutes, price, description)
       VALUES ($1, $2, $3, $4, $5)
       RETURNING id`,
      [salon_id, name, duration_minutes, price, description]
    );
    const addonId = addonRes.rows[0].id;

    // ðŸ”¹ Przypisz do wybranych usÅ‚ug tego salonu
    if (Array.isArray(service_ids) && service_ids.length > 0) {
      for (const sid of service_ids) {
        await pool.query(
          `INSERT INTO service_addon_links (service_id, addon_id)
           VALUES ($1, $2)
           ON CONFLICT DO NOTHING`,
          [sid, addonId]
        );
      }
    }

    res.json({ message: "âœ… Dodano usÅ‚ugÄ™ dodatkowÄ…", addon_id: addonId });
  } catch (err) {
    console.error("âŒ BÅ‚Ä…d przy dodawaniu dodatku:", err);
    res.status(500).json({ error: "BÅ‚Ä…d przy dodawaniu dodatku" });
  }
});



// --- Pobranie wszystkich dodatkÃ³w salonu z powiÄ…zaniami ---
app.get("/api/service-addons/all", verifyToken, requireProviderRole, async (req, res) => {
  try {
   const salonId = req.query.salon_id
  ? Number(req.query.salon_id)
  : (await pool.query("SELECT id FROM salons WHERE owner_uid = $1 LIMIT 1", [req.user.uid])).rows[0]?.id;


    const result = await pool.query(
      `
      SELECT a.*, 
             COALESCE(json_agg(s.name) FILTER (WHERE s.id IS NOT NULL), '[]') AS linked_services
      FROM service_addons a
      LEFT JOIN service_addon_links l ON a.id = l.addon_id
      LEFT JOIN services s ON l.service_id = s.id
      WHERE a.salon_id = $1
      GROUP BY a.id
      ORDER BY a.name;
      `,
      [salonId]
    );

    res.json(result.rows);
  } catch (err) {
    console.error("âŒ BÅ‚Ä…d przy pobieraniu dodatkÃ³w:", err);
    res.status(500).json({ error: "BÅ‚Ä…d serwera przy pobieraniu dodatkÃ³w" });
  }
});


// --- Edycja usÅ‚ugi ---
app.put("/api/services/:id", verifyToken, requireProviderRole, async (req, res) => {
  const { id } = req.params;
  const { name, duration_minutes, price, description } = req.body;

  try {
    // ðŸ”¹ SprawdÅº, czy usÅ‚uga naleÅ¼y do salonu wÅ‚aÅ›ciciela
    const serviceCheck = await pool.query(
      `SELECT s.id 
       FROM services s 
       JOIN salons sa ON s.salon_id = sa.id 
       WHERE s.id = $1 AND sa.owner_uid = $2`,
      [id, req.user.uid]
    );

    if (serviceCheck.rows.length === 0)
      return res.status(403).json({ error: "Brak uprawnieÅ„ do tej usÅ‚ugi" });

    const result = await pool.query(
      `UPDATE services
       SET name=$1, duration_minutes=$2, price=$3, description=$4
       WHERE id=$5
       RETURNING *`,
      [name, duration_minutes, price, description, id]
    );

    res.json({ message: "âœ… UsÅ‚uga zaktualizowana", service: result.rows[0] });
  } catch (err) {
    console.error("âŒ BÅ‚Ä…d edycji usÅ‚ugi:", err);
    res.status(500).json({ error: "BÅ‚Ä…d przy edycji usÅ‚ugi" });
  }
});

// --- Usuwanie usÅ‚ugi ---
app.delete("/api/services/:id", verifyToken, requireProviderRole, async (req, res) => {
  const { id } = req.params;

  try {
    const result = await pool.query(
      `DELETE FROM services
       WHERE id=$1 AND salon_id IN (
         SELECT id FROM salons WHERE owner_uid = $2
       ) RETURNING id`,
      [id, req.user.uid]
    );

    if (result.rows.length === 0)
      return res.status(404).json({ error: "Nie znaleziono usÅ‚ugi lub brak uprawnieÅ„" });

    res.json({ message: "ðŸ—‘ï¸ UsÅ‚uga usuniÄ™ta" });
  } catch (err) {
    console.error("âŒ BÅ‚Ä…d przy usuwaniu usÅ‚ugi:", err);
    res.status(500).json({ error: "BÅ‚Ä…d przy usuwaniu usÅ‚ugi" });
  }
});

// --- Edycja dodatku ---
app.put("/api/service-addons/:id", verifyToken, requireProviderRole, async (req, res) => {
  const { id } = req.params;
  const { name, duration_minutes, price, description } = req.body;

  try {
    const addonCheck = await pool.query(
      `SELECT a.id 
       FROM service_addons a 
       JOIN salons s ON a.salon_id = s.id 
       WHERE a.id = $1 AND s.owner_uid = $2`,
      [id, req.user.uid]
    );

    if (addonCheck.rows.length === 0)
      return res.status(403).json({ error: "Brak uprawnieÅ„ do tego dodatku" });

    const result = await pool.query(
      `UPDATE service_addons
       SET name=$1, duration_minutes=$2, price=$3, description=$4
       WHERE id=$5
       RETURNING *`,
      [name, duration_minutes, price, description, id]
    );

    res.json({ message: "âœ… Dodatek zaktualizowany", addon: result.rows[0] });
  } catch (err) {
    console.error("âŒ BÅ‚Ä…d edycji dodatku:", err);
    res.status(500).json({ error: "BÅ‚Ä…d przy edycji dodatku" });
  }
});

// --- Usuwanie dodatku ---
app.delete("/api/service-addons/:id", verifyToken, requireProviderRole, async (req, res) => {
  const { id } = req.params;

  try {
    const result = await pool.query(
      `DELETE FROM service_addons
       WHERE id=$1 AND salon_id IN (
         SELECT id FROM salons WHERE owner_uid = $2
       )
       RETURNING id`,
      [id, req.user.uid]
    );

    if (result.rows.length === 0)
      return res.status(404).json({ error: "Nie znaleziono dodatku lub brak uprawnieÅ„" });

    res.json({ message: "ðŸ—‘ï¸ Dodatek usuniÄ™ty" });
  } catch (err) {
    console.error("âŒ BÅ‚Ä…d przy usuwaniu dodatku:", err);
    res.status(500).json({ error: "BÅ‚Ä…d przy usuwaniu dodatku" });
  }
});




// --- Pobranie dodatkÃ³w przypisanych do konkretnej usÅ‚ugi (dla klienta) ---
app.get("/api/service-addons/by-service/:serviceId", verifyToken, async (req, res) => {
  try {
    const { serviceId } = req.params;
    const result = await pool.query(
      `
      SELECT a.*
      FROM service_addons a
      JOIN service_addon_links l ON a.id = l.addon_id
      WHERE l.service_id = $1 AND a.is_active = true
      ORDER BY a.name
      `,
      [serviceId]
    );
    res.json(result.rows);
  } catch (err) {
    console.error("âŒ BÅ‚Ä…d przy pobieraniu dodatkÃ³w:", err);
    res.status(500).json({ error: "BÅ‚Ä…d serwera" });
  }
});

// --- Publiczna lista salonÃ³w (dla klientÃ³w) ---
app.get("/api/salons/public", async (req, res) => {
  try {
    const result = await pool.query(`
      SELECT id, name, city, street, street_number, phone, description, image_url
      FROM salons
      WHERE is_active = true
      ORDER BY name;
    `);

    res.json(result.rows);
  } catch (err) {
    console.error("âŒ BÅ‚Ä…d pobierania salonÃ³w publicznych:", err);
    res.status(500).json({ error: "BÅ‚Ä…d pobierania salonÃ³w publicznych" });
  }
});


app.get("/api/services/by-salon/:salonId", async (req, res) => {
  try {
    const { salonId } = req.params;

    const result = await pool.query(
      `
      SELECT 
        s.id, 
        s.name, 
        s.duration_minutes, 
        s.price, 
        s.description, 
        s.image_url, 
        s.is_active, 
        s.created_at,
        COALESCE(
          json_agg(es.employee_id) FILTER (WHERE es.employee_id IS NOT NULL),
          '[]'
        ) AS employee_ids
      FROM services s
      LEFT JOIN employee_services es ON es.service_id = s.id
      WHERE s.salon_id = $1 AND s.is_active = true
      GROUP BY s.id
      ORDER BY s.name;
      `,
      [salonId]
    );

    res.json(result.rows);
  } catch (err) {
    console.error("âŒ BÅ‚Ä…d przy pobieraniu usÅ‚ug salonu:", err);
    res.status(500).json({ error: "BÅ‚Ä…d przy pobieraniu usÅ‚ug salonu" });
  }
});




// --- Pobierz pojedynczÄ… usÅ‚ugÄ™ po ID (dla klientÃ³w) ---
app.get("/api/service/:id", async (req, res) => {
  try {
    const { id } = req.params;
    const result = await pool.query(
      `SELECT id, salon_id, name, duration_minutes, price, description, image_url, is_active 
       FROM services 
       WHERE id = $1`,
      [id]
    );

    if (result.rows.length === 0) {
      return res.status(404).json({ error: "Nie znaleziono usÅ‚ugi" });
    }

    res.json(result.rows[0]);
  } catch (err) {
    console.error("âŒ BÅ‚Ä…d przy pobieraniu usÅ‚ugi:", err);
    res.status(500).json({ error: "BÅ‚Ä…d przy pobieraniu usÅ‚ugi" });
  }
});


// --- Lista WSZYSTKICH salonÃ³w zalogowanego wÅ‚aÅ›ciciela ---
app.get("/api/salons/mine/all", verifyToken, requireProviderRole, async (req, res) => {
  try {
    const result = await pool.query(
      "SELECT * FROM salons WHERE owner_uid = $1 ORDER BY created_at DESC",
      [req.user.uid]
    );
    res.json(result.rows);
  } catch (err) {
    console.error("âŒ BÅ‚Ä…d przy pobieraniu listy salonÃ³w:", err);
    res.status(500).json({ error: "BÅ‚Ä…d przy pobieraniu listy salonÃ³w" });
  }
});











































// --- Pobierz wszystkie dostÄ™pne kategorie ---
app.get("/api/categories", async (req, res) => {
  try {
    const result = await pool.query("SELECT * FROM categories ORDER BY name");
    res.json(result.rows);
  } catch (err) {
    console.error("âŒ BÅ‚Ä…d przy pobieraniu kategorii:", err);
    res.status(500).json({ error: "BÅ‚Ä…d przy pobieraniu kategorii" });
  }
});

// --- Przypisz kategorie do salonu ---
app.post("/api/salons/:id/categories", verifyToken, requireProviderRole, async (req, res) => {
  const { id } = req.params;
  const { category_ids } = req.body; // tablica ID kategorii

  if (!Array.isArray(category_ids))
    return res.status(400).json({ error: "category_ids musi byÄ‡ tablicÄ…" });

  try {
    // sprawdÅº, czy salon naleÅ¼y do wÅ‚aÅ›ciciela
    const salonCheck = await pool.query(
      "SELECT id FROM salons WHERE id=$1 AND owner_uid=$2",
      [id, req.user.uid]
    );
    if (salonCheck.rows.length === 0)
      return res.status(403).json({ error: "Brak uprawnieÅ„ do salonu" });

    // usuÅ„ stare powiÄ…zania
    await pool.query("DELETE FROM salon_categories WHERE salon_id=$1", [id]);

    // dodaj nowe powiÄ…zania
    for (const catId of category_ids) {
      await pool.query(
        `INSERT INTO salon_categories (salon_id, category_id)
         VALUES ($1, $2)
         ON CONFLICT DO NOTHING`,
        [id, catId]
      );
    }

    res.json({ message: "âœ… Kategorie przypisane do salonu" });
  } catch (err) {
    console.error("âŒ BÅ‚Ä…d przy przypisywaniu kategorii:", err);
    res.status(500).json({ error: "BÅ‚Ä…d przy przypisywaniu kategorii" });
  }
});

// --- Pobierz kategorie konkretnego salonu ---
app.get("/api/salons/:id/categories", async (req, res) => {
  const { id } = req.params;
  try {
    const result = await pool.query(
      `SELECT c.id, c.name
       FROM salon_categories sc
       JOIN categories c ON c.id = sc.category_id
       WHERE sc.salon_id = $1
       ORDER BY c.name`,
      [id]
    );
    res.json(result.rows);
  } catch (err) {
    console.error("âŒ BÅ‚Ä…d przy pobieraniu kategorii salonu:", err);
    res.status(500).json({ error: "BÅ‚Ä…d przy pobieraniu kategorii salonu" });
  }
});


































app.get("/api/appointments/unavailable-days", async (req, res) => {
  try {
    const { service_id, employee_id, year, month } = req.query;

    // ðŸ”¹ Walidacja parametrÃ³w
    if (!service_id && !employee_id) {
      return res.status(400).json({ error: "Brak service_id lub employee_id" });
    }
    if (!year || !month) {
      return res.status(400).json({ error: "Brak parametru year lub month" });
    }

    // ðŸ”¹ WspÃ³lny fragment generujÄ…cy dni z danego miesiÄ…ca
    const dateRangeSQL = `
      WITH month_days AS (
        SELECT generate_series(
          make_date($1::int, $2::int, 1),
          (make_date($1::int, $2::int, 1) + INTERVAL '1 month - 1 day')::date,
          interval '1 day'
        ) AS date
      )
    `;

    // ðŸ”¹ JeÅ›li wybrano konkretnego pracownika
    if (employee_id) {
      const query = `
        , emp AS (
          SELECT id, salon_id FROM employees WHERE id = $3
        ),
        schedule AS (
          SELECT day_of_week, open_time, close_time, is_day_off
          FROM employee_schedule
          WHERE employee_id = $3
        ),
        holidays AS (
          SELECT date FROM salon_holidays
          WHERE salon_id = (SELECT salon_id FROM emp)
        ),
        vacations AS (
          SELECT start_date, end_date FROM employee_vacations
          WHERE employee_id = $3
        ),
        appointments_summary AS (
          SELECT 
            date,
            SUM(EXTRACT(EPOCH FROM (end_time - start_time)) / 60) AS booked_minutes
          FROM appointments
          WHERE employee_id = $3 AND status = 'booked'
          GROUP BY date
        )
        SELECT 
          to_char(d.date, 'YYYY-MM-DD') AS date
        FROM month_days d
        WHERE
          -- Å›wiÄ™ta salonu
          d.date IN (SELECT date FROM holidays)
          OR -- urlop
          EXISTS (SELECT 1 FROM vacations v WHERE d.date BETWEEN v.start_date AND v.end_date)
          OR -- dzieÅ„ wolny
          (EXTRACT(DOW FROM d.date) IN (SELECT day_of_week FROM schedule WHERE is_day_off = true))
          OR -- w peÅ‚ni zajÄ™ty
          (
            (SELECT SUM(EXTRACT(EPOCH FROM (close_time - open_time)) / 60)
             FROM schedule s 
             WHERE s.day_of_week = EXTRACT(DOW FROM d.date)
            ) <= COALESCE((SELECT booked_minutes FROM appointments_summary a WHERE a.date = d.date), 0)
          )
        ORDER BY date;
      `;
      const result = await pool.query(`${dateRangeSQL}${query}`, [year, month, employee_id]);
      return res.json(result.rows.map((r) => r.date));
    }

    // ðŸ”¹ JeÅ›li â€ždowolnyâ€ â€” sprawdzamy wszystkich przypisanych do usÅ‚ugi
    const employeesRes = await pool.query(
      `SELECT e.id, e.salon_id
       FROM employees e
       JOIN employee_services es ON es.employee_id = e.id
       WHERE es.service_id = $1 AND e.is_active = true`,
      [service_id]
    );

    if (employeesRes.rows.length === 0) return res.json([]);

    const employees = employeesRes.rows;
    const salonId = employees[0].salon_id;

    // ðŸ”¹ ÅšwiÄ™ta salonu (dla wszystkich)
    const holidaysRes = await pool.query(
      `SELECT to_char(date, 'YYYY-MM-DD') AS date FROM salon_holidays WHERE salon_id = $1`,
      [salonId]
    );
    const holidays = holidaysRes.rows.map((r) => r.date);

    // ðŸ”¹ Zbierz dni niedostÄ™pne dla kaÅ¼dego pracownika
    const unavailableMap = new Map();

    for (const emp of employees) {
      const q = await pool.query(
        `${dateRangeSQL}
        SELECT 
          to_char(d.date, 'YYYY-MM-DD') AS date
        FROM month_days d
        WHERE
          d.date IN (SELECT date FROM salon_holidays WHERE salon_id = $4)
          OR EXISTS (SELECT 1 FROM employee_vacations v WHERE v.employee_id = $3 AND d.date BETWEEN v.start_date AND v.end_date)
          OR (EXTRACT(DOW FROM d.date) IN (SELECT day_of_week FROM employee_schedule WHERE employee_id = $3 AND is_day_off = true))
          OR (
            (SELECT SUM(EXTRACT(EPOCH FROM (close_time - open_time)) / 60)
             FROM employee_schedule s 
             WHERE s.employee_id = $3 AND s.day_of_week = EXTRACT(DOW FROM d.date)
            ) <= COALESCE((
              SELECT SUM(EXTRACT(EPOCH FROM (end_time - start_time)) / 60)
              FROM appointments a
              WHERE a.employee_id = $3 AND a.date = d.date AND a.status = 'booked'
            ), 0)
          )
        `,
        [year, month, emp.id, salonId]
      );

      q.rows.forEach((r) => {
        const date = r.date;
        unavailableMap.set(date, (unavailableMap.get(date) || 0) + 1);
      });
    }

    // ðŸ”¹ Dni, w ktÃ³rych WSZYSCY sÄ… niedostÄ™pni (lub Å›wiÄ™ta)
    const totalEmps = employees.length;
    const fullyUnavailable = holidays.filter(Boolean);

    for (const [date, count] of unavailableMap.entries()) {
      if (count === totalEmps) fullyUnavailable.push(date);
    }

    const unique = [...new Set(fullyUnavailable)];
    res.json(unique);
  } catch (err) {
    console.error("âŒ BÅ‚Ä…d /unavailable-days:", err);
    res.status(500).json({ error: "BÅ‚Ä…d serwera" });
  }
});



































// --- Test backendu ---
app.get("/", (req, res) => res.send("ðŸš€ Backend dziaÅ‚a poprawnie"));

// --- Uruchomienie serwera ---
const PORT = process.env.PORT || 5000;
app.listen(PORT, '0.0.0.0', () => {
  console.log(`âœ… Server running on http://0.0.0.0:${PORT}`);
});
