import React, { useState, useRef, useEffect, useMemo, useCallback } from "react";
import { ChevronLeft, ChevronRight, Plus } from "lucide-react";
import { DndProvider, useDrag, useDrop } from "react-dnd";
import { MultiBackend, TouchTransition, MouseTransition } from "dnd-multi-backend";
import { HTML5Backend, getEmptyImage } from "react-dnd-html5-backend";
import { TouchBackend } from "react-dnd-touch-backend";
import axios from "axios";
axios.interceptors.request.use((config) => {
  if (config.method === "get") {
    config.params = config.params || {};
    config.params._t = Date.now(); // ‚Üê anty-cache

    config.headers["Cache-Control"] = "no-cache, no-store, must-revalidate";
    config.headers["Pragma"] = "no-cache";
    config.headers["Expires"] = "0";
  }
  return config;
});

import { useAuth } from "../../components/AuthProvider";
import io from "socket.io-client";
import AppointmentModal from "../../components/AppointmentModal";
import TimeOffModal from "../../components/TimeOffModal";
import { useNavigate } from "react-router-dom";

const socket = io(import.meta.env.VITE_API_URL || "http://localhost:5000");

const defaultDayStart = 6 * 60;
const defaultDayEnd = 23 * 60;
const HOUR_HEIGHT = 100;
const weekDays = ["Pon", "Wt", "≈ör", "Czw", "Pt", "Sob", "Niedz"];
const ItemTypes = { APPOINTMENT: "appointment" };

const HTML5toTouch = {
  backends: [
    { id: "html5", backend: HTML5Backend, transition: MouseTransition },
    {
      id: "touch",
      backend: TouchBackend,
      options: { enableMouseEvents: true, delayTouchStart: 0 },
      transition: TouchTransition,
    },
  ],
};

const styles = `/* (tw√≥j stylesheet ‚Äî bez zmian, pominƒÖ≈Çem tu skr√≥tem w komentarzu aby nie za≈õmiecaƒá) */
* {
    -webkit-user-select: none !important;
    user-select: none !important;
    -ms-user-select: none !important;
  }

  html, body {
    -webkit-user-select: none !important;
    user-select: none !important;
    -ms-user-select: none !important;
    touch-action: pan-y;
  }
  


  .calendar-root { 
    font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; 
    user-select:none;
    background: #F9FAFB;
  }
  .day-pill { 
    min-width:44px; 
    display:flex; 
    flex-direction:column; 
    align-items:center; 
    padding:8px 8px; 
    border-radius:10px; 
    cursor:pointer;
  }
  .day-pill.active { 
    background:#FFEBD6; 
    color:#E55B10; 
    font-weight:700; 
    box-shadow:0 4px 14px rgba(14, 20, 30, 0.06);
  }
  .calendar-body { display:flex; gap:10px; padding:10px 4px; overflow:hidden; }
  .times-column { width:48px; flex:0 0 48px; color:#6B7280; font-weight:600; font-size:12px; }
  .employee-col { background:transparent; border-radius:12px; position:relative; scroll-snap-align:start; }
  .employee-header { display:flex; gap:8px; align-items:center; padding:8px 6px; border-bottom:1px solid rgba(0,0,0,0.04); }
  .avatar { width:32px; height:32px; border-radius:50%; object-fit:cover; box-shadow:0 1px 3px rgba(2,6,23,0.06); }
  .work-hours { font-size:11px; color:#6B7280; }
  .time-grid { position:relative; padding:0px 6px; height: calc(var(--hours) * var(--hour-height)); background:transparent; }

  .event-card {
    position: absolute;
    left: 4px;
    right: 4px;
    border-radius: 10px;
    padding: 4px 6px;
    box-shadow: 0 4px 12px rgba(12, 18, 26, 0.06);
    font-weight: 500;
    font-size: 12px;
    color: #111827;
    
    word-wrap: break-word;
    cursor: pointer;
    display: flex;
    flex-direction: column;
    justify-content: center;
    text-align: left;
    transition: transform 0.15s ease, box-shadow 0.15s ease;
    overflow: hidden;
  }

  .event-card:hover {
    transform: scale(1.03);
    box-shadow: 0 6px 18px rgba(0, 0, 0, 0.15);
    z-index: 50;
  }

  .event-card-content {
    overflow-y: auto;
    max-height: 100%;
    scrollbar-width: none;
  }
  .event-card-content::-webkit-scrollbar {
    display: none;
  }

  .event-card.small {
    font-size: 10px;
    padding: 2px 4px;
  }

  .floating-add {
    position:fixed;
    right:20px;
    bottom:90px;
    z-index:60;
    width:56px;
    height:56px;
    border-radius:999px;
    display:flex;
    align-items:center;
    justify-content:center;
    background:linear-gradient(180deg,#fb923c,#ef4444);
    color:white;
    box-shadow:0 10px 30px rgba(15,23,42,0.16);
  }
  .drag-line {
    position:absolute;
    left:0;
    right:0;
    height:0;
    border-top:2px dashed rgba(229,91,16,0.7);
    pointer-events:none;
    opacity:0;
    transform:scaleY(0.95);
    transition:opacity 0.2s ease, transform 0.2s ease;
  }
  .drag-line.visible { opacity:1; transform:scaleY(1); }
  
  .timeoff-block { /* ... */ }
  .timeoff-block.expired { /* ... */ }
  .offhours-block { /* ... */ }
  .dayoff-block { /* ... */ }
  
  
  timeoff-block,
.timeoff-block * {
  user-select: none !important;
  -webkit-user-select: none !important;
  -ms-user-select: none !important;
}

.day-strip::-webkit-scrollbar {
  display: none !important;
}

.day-strip {
  -ms-overflow-style: none !important; /* IE/Edge */
  scrollbar-width: none !important; /* Firefox */
}
  
`;

/* helpery */
const pad2 = (n) => String(n).padStart(2, "0");
const timeToMinutes = (timeStr) => {
  if (!timeStr) return 0;
  const [h, m] = timeStr.split(":").map(Number);
  return h * 60 + (m || 0);
};
const minutesToHHMM = (m) => `${pad2(Math.floor(m / 60))}:${pad2(Math.floor(m % 60))}`;
const formatHHMM = (timeStr) => (timeStr ? timeStr.split(":").slice(0, 2).join(":") : "");
const formatTime = (t) => (t ? t.substring(0, 5) : "");
const snap5 = (min) => Math.round(min / 5) * 5;


function formatDateLocal(date) {
  if (!(date instanceof Date)) date = new Date(date);
  const y = date.getFullYear();
  const m = String(date.getMonth() + 1).padStart(2, "0");
  const d = String(date.getDate()).padStart(2, "0");
  return `${y}-${m}-${d}`;
}

function fixDateLocal(isoStr) {
  if (!isoStr) return "";
  const d = new Date(isoStr);
  return `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, "0")}-${String(d.getDate()).padStart(2, "0")}`;
}

function isDayOffFlag(raw) {
  if (raw === undefined || raw === null) return false;
  if (typeof raw === "object") {
    const v = raw.is_day_off ?? raw.day_off;
    return isDayOffFlag(v);
  }
  if (typeof raw === "boolean") return raw;
  if (typeof raw === "number") return raw === 1;
  if (typeof raw === "string") {
    const v = raw.trim().toLowerCase();
    return v === "1" || v === "true" || v === "tak" || v === "yes";
  }
  return false;
}
function stringToPastelColor(str) {
  if (!str) return "#FFF1E6";
  let hash = 0;
  for (let i = 0; i < str.length; i++) {
    hash = str.charCodeAt(i) + ((hash << 5) - hash);
  }
  const h = Math.abs(hash) % 360;
  const s = 70 + (Math.abs(hash) % 10);
  const l = 85 + (Math.abs(hash) % 5);
  return `hsl(${h}, ${s}%, ${l}%)`;
}

/* ---------- DraggableEvent: poprawiona wersja (klik vs hold vs drag) ---------- */
function DraggableEvent({
  appointment,
  children,
  isEditing,
  onSelect,
  onEnterEditMode,
  resizing, // <-- DODANE: ref przekazywany z zewnƒÖtrz
}) {
  const [dragEnabled, setDragEnabled] = useState(false);

  const holdTimer = useRef(null);
  const hasHeld = useRef(false);
  const pointerDownTime = useRef(0);
  const moved = useRef(false);

  const [{ isDragging }, drag, preview] = useDrag(
    () => ({
      type: ItemTypes.APPOINTMENT,
      item: { ...appointment, dragMode: true },
      canDrag: () => dragEnabled && isEditing && !resizing.current,
      collect: (monitor) => ({
        isDragging: monitor.isDragging(),
      }),
    }),
    [dragEnabled, isEditing, resizing.current]
  );

  useEffect(() => {
    preview(getEmptyImage(), { captureDraggingState: true });
  }, [preview]);

  // ----------------------------------------
  // POINTER DOWN
  // ----------------------------------------
  const handlePointerDown = (e) => {
    // je≈õli klikniƒôto STRZA≈ÅKƒò -> NIE pozwalamy na drag/klik/hold
    if (e.target.dataset.resizeHandle) {
      resizing.current = true;
      moved.current = true; 
      dragEnabled.current = false;
      clearTimeout(holdTimer.current);
      return;
    }

    pointerDownTime.current = performance.now();
    hasHeld.current = false;
    moved.current = false;

    clearTimeout(holdTimer.current);

    holdTimer.current = setTimeout(() => {
      if (!moved.current) {
        hasHeld.current = true;
        onEnterEditMode(appointment.id);
        setDragEnabled(true);
      }
    }, 250);
  };

  const handlePointerMove = (e) => {
    if (resizing.current) return;

    if (Math.abs(e.movementY) > 4 || Math.abs(e.movementX) > 4) {
      moved.current = true;
      clearTimeout(holdTimer.current);
    }
  };

  const handlePointerUp = (e) => {
    if (resizing.current) {
      resizing.current = false;
      setDragEnabled(false);
      return;
    }

    clearTimeout(holdTimer.current);

    if (hasHeld.current) {
      setDragEnabled(false);
      return;
    }

    const pressTime = performance.now() - pointerDownTime.current;

    if (!moved.current && pressTime < 180) {
      onSelect(appointment);
      return;
    }

    setDragEnabled(false);
  };

  return (
    <div
      ref={drag}
      onPointerDown={handlePointerDown}
      onPointerMove={handlePointerMove}
      onPointerUp={handlePointerUp}
      style={{
        touchAction: isEditing ? "none" : "pan-y",
        cursor: dragEnabled && !resizing.current ? "grabbing" : "pointer",
        opacity: isDragging ? 0.6 : 1,
        userSelect: "none",
      }}
    >
      {children}
    </div>
  );
}




function EditableTimeOff({ off, employee_id, children, isEditing, onEnterEditMode, onSelect, resizing }) {
  const holdTimer = useRef(null);
  const pointerDownTime = useRef(0);
  const moved = useRef(false);
  const held = useRef(false);

  const handlePointerDown = (e) => {
    if (e.target.dataset.resizeHandle) return;

    pointerDownTime.current = performance.now();
    moved.current = false;
    held.current = false;

    clearTimeout(holdTimer.current);

    holdTimer.current = setTimeout(() => {
      held.current = true;
      onEnterEditMode(off.id);
      resizing.current = false;
    }, 250);
  };

  const handlePointerMove = (e) => {
    if (resizing.current) return;
    if (Math.abs(e.movementX) > 3 || Math.abs(e.movementY) > 3) {
      moved.current = true;
      clearTimeout(holdTimer.current);
    }
  };

  const handlePointerUp = (e) => {
    clearTimeout(holdTimer.current);

    if (resizing.current) return;

    const pressTime = performance.now() - pointerDownTime.current;

    if (!moved.current && !held.current && pressTime < 200) {
      onSelect(off);
      return;
    }

    if (held.current) return;
  };

  return (
    <div
      onPointerDown={handlePointerDown}
      onPointerMove={handlePointerMove}
      onPointerUp={handlePointerUp}
      style={{
        touchAction: isEditing ? "none" : "pan-y",
        userSelect: "none",
        position: "absolute",
        zIndex: isEditing ? 999 : 5,
      }}
    >
      {children}
    </div>
  );
}



/* ---------- DroppableTimeGrid (bez wiƒôkszych zmian, zostawione) ---------- */
function DroppableTimeGrid({
  day,
  employee,
  onDrop,
  currentDate,
  dayStartMin,
  dayEndMin,
  HOUR_HEIGHT,
  children,
}) {
  const containerRef = useRef(null);
  const [dragLinePos, setDragLinePos] = useState(null);
  const [dragTime, setDragTime] = useState(null);
  const [shadowEvent, setShadowEvent] = useState(null);
  const [isSnapped, setIsSnapped] = useState(false);

  const SNAP_THRESHOLD_MINUTES = 1;

  const getMinutesFromPageY = (pageY) => {
    const rect = containerRef.current?.getBoundingClientRect();
    if (!rect) return dayStartMin;
    const topOnPage = rect.top + window.scrollY;
    const offsetY = pageY - topOnPage;
    const minutesFromTop = (offsetY / HOUR_HEIGHT) * 60;
    return dayStartMin + minutesFromTop;
  };

  const buildSnapPoints = (duration) => {
    const pts = [];
    pts.push(dayStartMin);
    pts.push(dayEndMin - duration);
    if (employee?.appointments && Array.isArray(employee.appointments)) {
      employee.appointments.forEach((a) => {
        const aStart = timeToMinutes(a.start_time);
        const aEnd = timeToMinutes(a.end_time);
        if (!Number.isNaN(aEnd)) pts.push(aEnd);
        if (!Number.isNaN(aStart)) pts.push(aStart);
      });
    }
    const uniq = Array.from(new Set(pts)).sort((x, y) => x - y);
    return uniq;
  };

  const [{ isOver, canDrop }, drop] = useDrop(
    () => ({
      accept: ItemTypes.APPOINTMENT,
      canDrop: () => true,
      hover: (item, monitor) => {
        if (!monitor.canDrop()) return;
        const clientOffset = monitor.getClientOffset();
        if (!clientOffset) return;
        const pageY = clientOffset.y + window.scrollY;
        const currentMinutesRaw = getMinutesFromPageY(pageY);
        const duration = timeToMinutes(item.end_time) - timeToMinutes(item.start_time);
        let boundedStart = Math.max(dayStartMin, Math.min(currentMinutesRaw, dayEndMin - duration));
        const snapPts = buildSnapPoints(duration);
        let nearest = boundedStart;
        let nearestDist = Infinity;
        for (const p of snapPts) {
          const d = Math.abs(boundedStart - p);
          if (d < nearestDist) {
            nearestDist = d;
            nearest = p;
          }
        }
        if (nearestDist <= SNAP_THRESHOLD_MINUTES) {
          boundedStart = nearest;
          setIsSnapped(true);
        } else {
          setIsSnapped(false);
        }
		boundedStart = snap5(boundedStart);

        const boundedEnd = boundedStart + duration;
        const topPx = ((boundedStart - dayStartMin) / 60) * HOUR_HEIGHT;
        const heightPx = ((boundedEnd - boundedStart) / 60) * HOUR_HEIGHT;
        setDragLinePos(topPx);
        setDragTime(minutesToHHMM(Math.round(boundedStart)));
        setShadowEvent({
          ...item,
          start_time: minutesToHHMM(Math.round(boundedStart)),
          end_time: minutesToHHMM(Math.round(boundedEnd)),
          top: topPx,
          height: heightPx,
        });
      },
      drop: (item, monitor) => {
        if (!monitor.canDrop()) {
          alert("‚ùå Ten pracownik ma dzi≈õ dzie≈Ñ wolny!");
          return;
        }
        const clientOffset = monitor.getClientOffset();
        if (!clientOffset) return;
        const pageY = clientOffset.y + window.scrollY;
        const currentMinutesRaw = getMinutesFromPageY(pageY);
        const duration = timeToMinutes(item.end_time) - timeToMinutes(item.start_time);
        let boundedStart = Math.max(dayStartMin, Math.min(currentMinutesRaw, dayEndMin - duration));
        const snapPts = buildSnapPoints(duration);
        let nearest = boundedStart;
        let nearestDist = Infinity;
        for (const p of snapPts) {
          const d = Math.abs(boundedStart - p);
          if (d < nearestDist) {
            nearestDist = d;
            nearest = p;
          }
        }
        if (nearestDist <= SNAP_THRESHOLD_MINUTES) boundedStart = nearest;
        const dropStart = snap5(boundedStart);
		const dropEnd = dropStart + duration;

        if (item.dragMode !== true && employee?.working_hours) {
          const { open, close } = employee.working_hours;
          const startMin = timeToMinutes(open);
          const endMin = timeToMinutes(close);
          if (dropStart < startMin || dropEnd > endMin) {
            alert(`‚õî Poza godzinami pracy (${open} - ${close})`);
            return;
          }
        }

        onDrop({
          id: item.id,
          fromEmployeeId: item.employee_id,
          toEmployeeId: employee.employee_id,
          start_time: minutesToHHMM(dropStart),
          end_time: minutesToHHMM(dropEnd),
          date: day,
          dragMode: true,
        });
      },
      collect: (monitor) => ({
        isOver: monitor.isOver(),
        canDrop: monitor.canDrop(),
      }),
    }),
    [employee?.day_off, employee?.employee_id, employee?.appointments, dayStartMin, dayEndMin, HOUR_HEIGHT]
  );

  const setRefs = (el) => {
    containerRef.current = el;
    drop(el);
  };

  useEffect(() => {
    if (!isOver) {
      setDragLinePos(null);
      setDragTime(null);
      setShadowEvent(null);
      setIsSnapped(false);
    }
  }, [isOver]);

  return (
    <div ref={setRefs} style={{ position: "relative" }}>
      {!employee?.day_off && employee?.working_hours && (
        <>
          {timeToMinutes(formatHHMM(employee.working_hours.open)) > dayStartMin && (
            <div
              className="offhours-block"
              style={{
                position: "absolute",
                top: 0,
                left: "4px",
                right: "4px",
                height: `${((timeToMinutes(formatHHMM(employee.working_hours.open)) - dayStartMin) / 60) * HOUR_HEIGHT}px`,
                display: "flex",
                justifyContent: "center",
                alignItems: "center",
                pointerEvents: "none",
                background: "rgba(0,0,0,0.05)",
                borderRadius: "10px",
                color: "#6B7280",
                fontSize: "12px",
                fontWeight: 500,
              }}
            >
              Poza godzinami pracy
            </div>
          )}

          {timeToMinutes(formatHHMM(employee.working_hours.close)) < dayEndMin && (
            <div
              className="offhours-block"
              style={{
                position: "absolute",
                bottom: 0,
                left: "4px",
                right: "4px",
                height: `${((dayEndMin - timeToMinutes(formatHHMM(employee.working_hours.close))) / 60) * HOUR_HEIGHT}px`,
                display: "flex",
                justifyContent: "center",
                alignItems: "center",
                pointerEvents: "none",
                background: "rgba(0,0,0,0.05)",
                borderRadius: "10px",
                color: "#6B7280",
                fontSize: "12px",
                fontWeight: 500,
              }}
            >
              Poza godzinami pracy
            </div>
          )}
        </>
      )}

      {employee?.day_off && (
        <div
          className="dayoff-block"
          style={{
            position: "absolute",
            inset: 0,
            display: "flex",
            justifyContent: "center",
            alignItems: "center",
            pointerEvents: "none",
          }}
        >
          üí§ Dzie≈Ñ wolny
        </div>
      )}

      {children}

      {dragLinePos !== null && (
        <div
          className={`drag-line ${isOver ? "visible" : ""}`}
          style={{
            top: `${dragLinePos}px`,
            zIndex: 200,
            borderTop: isSnapped ? "3px solid rgba(229,91,16,0.95)" : undefined,
          }}
        >
          <div
            style={{
              position: "absolute",
              top: 0,
              left: 0,
              right: 0,
              borderTop: isSnapped ? "3px solid rgba(229,91,16,0.95)" : "2px dashed rgba(229,91,16,0.9)",
              pointerEvents: "none",
            }}
          />
          <div
            style={{
              position: "absolute",
              left: 6,
              top: -18,
              background: "#E55B10",
              color: "white",
              fontSize: 11,
              padding: "2px 6px",
              borderRadius: 6,
              fontWeight: 600,
              boxShadow: "0 2px 6px rgba(0,0,0,0.2)",
              pointerEvents: "none",
              zIndex: 201,
            }}
          >
            {dragTime}
          </div>
        </div>
      )}

      {shadowEvent && (
        <div
          className="event-card"
          style={{
            position: "absolute",
            top: `${shadowEvent.top}px`,
            left: "4px",
            right: "4px",
            height: `${shadowEvent.height}px`,
            background: stringToPastelColor(shadowEvent.service_name),
            opacity: 0.8,
            zIndex: 100,
            pointerEvents: "none",
          }}
        >
          <div className="event-card-content" style={{ lineHeight: "0.8!important" }}>
            <div style={{ fontWeight: 600, fontSize: 12, marginBottom: 1, lineHeight: "0.8!important" }}>
              {shadowEvent.start_time} - {shadowEvent.end_time}
            </div>
            <div style={{ fontSize: 12, marginBottom: 0, lineHeight: "0.8!important" }}>{shadowEvent.client_name}</div>
            <div style={{ fontSize: 11, opacity: 0.8, marginTop: -4, lineHeight: "0.8!important" }}>
              {shadowEvent.service_name}
              {shadowEvent.addons && shadowEvent.addons.trim() !== "" && <span> + {shadowEvent.addons}</span>}
            </div>
          </div>
        </div>
      )}
    </div>
  );
}

/* ---------- G≈Ç√≥wny komponent z dodatkowymi funkcjami resize ---------- */
export default function EmployeeCalendar() {
  const navigate = useNavigate();
  const { firebaseUser } = useAuth();
  
  const backendBase = import.meta.env.VITE_API_URL;
  const [payload, setPayload] = useState({ employees: [] });

  const resizing = useRef(false);
  const pointerDownTime = useRef(0);
const holdTimeout = useRef(null);

  const initial = new Date();
  initial.setHours(0, 0, 0, 0);
  const [activeDay, setActiveDay] = useState(initial);
  const activeDayRef = useRef(activeDay);
  useEffect(() => {
    activeDayRef.current = activeDay;
  }, [activeDay]);

  const [selectedAppointment, setSelectedAppointment] = useState(null);
  const [modalOpen, setModalOpen] = useState(false);
  const [selectedTimeOff, setSelectedTimeOff] = useState(null);
  const [timeOffModalOpen, setTimeOffModalOpen] = useState(false);
  const [conflictModal, setConflictModal] = useState({ visible: false, retryAction: null });

  // nowy: id eventu w trybie edycji (pokazuje kropki)
  const [editingEventId, setEditingEventId] = useState(null);

  axios.defaults.headers.get["Cache-Control"] = "no-store, no-cache, must-revalidate, proxy-revalidate";
  axios.defaults.headers.get["Pragma"] = "no-cache";
  axios.defaults.headers.get["Expires"] = "0";

  const axiosNoCache = async (url, options = {}) => {
    const timestamp = Date.now();
    const mergedOptions = {
      ...options,
      params: { ...(options.params || {}), _t: timestamp },
      headers: {
        ...(options.headers || {}),
        "Cache-Control": "no-store, no-cache, must-revalidate, proxy-revalidate",
        Pragma: "no-cache",
        Expires: "0",
      },
    };
    return axios.get(url, mergedOptions);
  };
  
  
  // GLOBALNY BLOK SCROLLA PODCZAS EDYCJI
useEffect(() => {
  if (resizing.current || editingEventId !== null) {
    document.body.style.overflow = "hidden";
  } else {
    document.body.style.overflow = "";
  }

  return () => {
    document.body.style.overflow = "";
  };
}, [editingEventId]);

  

  const calendarRange = useMemo(() => {
    let start = defaultDayStart;
    let end = defaultDayEnd;
    if (payload?.employees?.length) {
      const opens = payload.employees
        .filter((e) => e.working_hours && !e.day_off && e.working_hours.open)
        .map((e) => timeToMinutes(formatHHMM(e.working_hours.open)));
      const closes = payload.employees
        .filter((e) => e.working_hours && !e.day_off && e.working_hours.close)
        .map((e) => timeToMinutes(formatHHMM(e.working_hours.close)));
      if (opens.length > 0) start = Math.min(...opens);
      if (closes.length > 0) end = Math.max(...closes);
      if (end <= start) end = start + 8 * 60;
    }
    return { dayStartMin: start, dayEndMin: end, HOUR_HEIGHT };
  }, [payload.employees]);

  useEffect(() => {
    const fetchCalendar = async () => {
      try {
        if (!firebaseUser) return;
        const token = await firebaseUser.getIdToken?.();
        if (!token) return;

        const res = await axios.get(`${backendBase}/api/calendar/shared`, {
          headers: { Authorization: `Bearer ${token}` },
          params: { date: formatDateLocal(activeDay) },
        });

        console.group("üì• FETCH /api/calendar/shared ‚Äî RAW RESPONSE");
        console.log("‚û°Ô∏è res.data:", res.data);
        console.group("üì¶ VACATION / TIME_OFF DEBUG");
        res.data.employees.forEach((e) => {
          console.log(
            `EMP ${e.employee_id} (${e.employee_name})`,
            {
              raw: e,
              vacations: e.vacations,
              time_off: e.time_off,
              day_off: e.day_off,
              is_day_off: e.is_day_off,
            }
          );
        });
        console.groupEnd();

        if (res.data?.employees) {
          res.data.employees.forEach((e) => {
            console.log(
              `üë§ EMPLOYEE ${e.employee_id} (${e.employee_name})`,
              {
                day_off: e.day_off,
                schedule: e.working_hours,
                vacations: e.vacations,
                time_off: e.time_off,
                appointments: e.appointments
              }
            );
          });
        }
        console.groupEnd();

        const normalized = {
          ...res.data,
          employees: res.data.employees.map((e) => ({
            ...e,
            day_off: Boolean(e.day_off || e.is_day_off),
            time_off: e.time_off ?? [],
            appointments: e.appointments ?? [],
          })),
        };

        setPayload(normalized);

      } catch (err) {
        console.error("‚ùå B≈ÇƒÖd pobierania kalendarza:", err);
      }
    };

    if (firebaseUser) fetchCalendar();
  }, [firebaseUser, activeDay, backendBase]);

  useEffect(() => {
    socket.on("calendar_updated", async (payloadSocket) => {
      try {
        if (!firebaseUser) return;
        const token = await firebaseUser.getIdToken?.();
        if (!token) return;
        const res = await axios.get(`${backendBase}/api/calendar/shared`, {
          headers: { Authorization: `Bearer ${token}` },
          params: { date: formatDateLocal(activeDay) },
        });
        const normalized = {
          ...res.data,
          employees: res.data.employees.map((e) => ({
            ...e,
            day_off: isDayOffFlag(e),
            time_off: e.time_off ?? [],
            appointments: e.appointments ?? [],
          })),
        };
        setPayload(normalized);
      } catch (err) {
        console.error("‚ùå B≈ÇƒÖd podczas auto-od≈õwie≈ºania:", err);
      }
    });
    return () => socket.off("calendar_updated");
  }, [firebaseUser, activeDay, backendBase]);

  useEffect(() => {
    const logInterval = setInterval(() => {
      console.log("üïì [LOG] Aktualny activeDay:", formatDateLocal(activeDay), "(", activeDay.toLocaleDateString("pl-PL", { weekday: "long" }), ")");
    }, 5000);
    return () => clearInterval(logInterval);
  }, [activeDay]);

  useEffect(() => {
    console.log("üìÖ Zmieniono activeDay na:", formatDateLocal(activeDay), "(", activeDay.toLocaleDateString("pl-PL", { weekday: "long" }), ")");
  }, [activeDay]);

  useEffect(() => {
    let dragging = false;
    let switchTimeout = null;
    const edgeZone = 0.1;
    function onMove(e) {
      if (!dragging) return;
      const x = e.touches ? e.touches[0].clientX : e.clientX;
      const w = window.innerWidth;
      const leftEdge = w * edgeZone;
      const rightEdge = w - w * edgeZone;
      if (x < leftEdge) scheduleDayChange(-1);
      else if (x > rightEdge) scheduleDayChange(1);
    }
    function onStart() {
      dragging = true;
    }
    function onEnd() {
      dragging = false;
      clearTimeout(switchTimeout);
      switchTimeout = null;
    }
    function scheduleDayChange(direction) {
      if (switchTimeout) return;
      switchTimeout = setTimeout(() => {
        setActiveDay((prev) => {
          const newDate = new Date(prev);
          newDate.setDate(prev.getDate() + direction);
          return newDate;
        });
        switchTimeout = null;
      }, 600);
    }
    window.addEventListener("dragstart", onStart);
    window.addEventListener("dragend", onEnd);
    window.addEventListener("touchstart", onStart);
    window.addEventListener("touchend", onEnd);
    window.addEventListener("mousemove", onMove);
    window.addEventListener("touchmove", onMove);
    return () => {
      clearTimeout(switchTimeout);
      window.removeEventListener("dragstart", onStart);
      window.removeEventListener("dragend", onEnd);
      window.removeEventListener("touchstart", onStart);
      window.removeEventListener("touchend", onEnd);
      window.removeEventListener("mousemove", onMove);
      window.removeEventListener("touchmove", onMove);
    };
  }, [setActiveDay]);

  const handleDrop = useCallback(
    async ({ id, fromEmployeeId, toEmployeeId, start_time, end_time, date, dragMode = false })=> {
      console.group("üéØ DROP EVENT ‚Äî handleDrop()");
      console.log("ID:", id);
      console.log("FROM EMP:", fromEmployeeId);
      console.log("TO EMP:", toEmployeeId);
      console.log("DATE:", date);
      console.log("START:", start_time);
      console.log("END:", end_time);
      console.groupEnd();

      try {
        if (!firebaseUser) {
          console.warn("‚ö†Ô∏è Brak zalogowanego u≈ºytkownika ‚Äî przerwano handleDrop");
          return;
        }
        const token = await firebaseUser.getIdToken();
        const targetEmp = payload.employees.find((e) => e.employee_id === toEmployeeId);
        if (!dragMode && targetEmp?.day_off === true) {
          alert("‚ùå Ten pracownik ma dzi≈õ dzie≈Ñ wolny!");
          return;
        }

        if (!dragMode && targetEmp?.working_hours) {
          const wh = targetEmp.working_hours;
          const open = wh.open;
          const close = wh.close;

          if (start_time < open || end_time > close) {
            alert(`‚õî Poza godzinami pracy (${open} - ${close})`);
            return;
          }
        }

        const sendDate = date || formatDateLocal(activeDayRef.current || activeDay);
        await axios.put(
          `${backendBase}/api/calendar/shared/${id}`,
          { employee_id: toEmployeeId, date: sendDate, start_time, end_time },
          { headers: { Authorization: `Bearer ${token}` } }
        );
        setPayload((prev) => {
          const employees = prev.employees.map((e) => ({ ...e, appointments: [...(e.appointments || [])] }));
          let moved = null;
          for (const e of employees) {
            const idx = e.appointments.findIndex((a) => a.id === id);
            if (idx !== -1) {
              moved = { ...e.appointments[idx] };
              e.appointments.splice(idx, 1);
              break;
            }
          }
          if (!moved) return prev;
          moved.start_time = start_time;
          moved.end_time = end_time;
          moved.employee_id = toEmployeeId;
          const target = employees.find((e) => e.employee_id === toEmployeeId);
          if (target) {
            target.appointments.push(moved);
            target.appointments.sort((a, b) => timeToMinutes(a.start_time) - timeToMinutes(b.start_time));
          }
          return { ...prev, employees };
        });
      } catch (err) {
        if (err.response?.status === 409) {
          setConflictModal({
            visible: true,
            retryAction: () =>
              handleDropForce({
                id,
                fromEmployeeId,
                toEmployeeId,
                start_time,
                end_time,
              }),
          });
        } else {
          console.error("‚ùå B≈ÇƒÖd aktualizacji terminu:", err);
          alert("B≈ÇƒÖd aktualizacji wizyty!");
        }
      }
    },
    [firebaseUser, backendBase, activeDay, payload]
  );

  const handleDropForce = useCallback(
    async ({ id, fromEmployeeId, toEmployeeId, start_time, end_time }) => {
      try {
        if (!firebaseUser) {
          console.warn("‚ö†Ô∏è Brak u≈ºytkownika ‚Äî przerwano handleDropForce");
          return;
        }
        const token = await firebaseUser.getIdToken();
        const date = formatDateLocal(activeDayRef.current || new Date());
        await axios.put(
          `${backendBase}/api/calendar/shared/${id}`,
          { employee_id: toEmployeeId, date, start_time, end_time, force: true },
          { headers: { Authorization: `Bearer ${token}` } }
        );
        setConflictModal({ visible: false, retryAction: null });
        alert("‚úÖ Zmieniono mimo kolizji.");
      } catch (error) {
        console.error("‚ùå B≈ÇƒÖd wymuszonej zmiany:", error);
        alert("Nie uda≈Ço siƒô zapisaƒá nawet z wymuszeniem.");
      }
    },
    [firebaseUser, backendBase]
  );

  /* ---------- Resize helpers (live + end) ---------- */
  const onResizeLive = useCallback(({ id, employee_id, start_time, end_time }) => {
    setPayload((prev) => {
      const employees = prev.employees.map((e) => ({ ...e, appointments: [...(e.appointments || [])] }));
      const emp = employees.find((e) => e.employee_id === employee_id);
      if (!emp) return prev;
      const app = emp.appointments.find((a) => a.id === id);
      if (!app) return prev;
      app.start_time = start_time;
      app.end_time = end_time;
      return { ...prev, employees };
    });
  }, []);

const onResizeLive_TimeOff = useCallback(({ id, employee_id, start_time, end_time }) => {
  setPayload((prev) => {
    const employees = prev.employees.map((e) => ({ ...e, time_off: [...(e.time_off || [])] }));
    const emp = employees.find((e) => e.employee_id === employee_id);
    if (!emp) return prev;

    const off = emp.time_off.find((t) => t.id === id);
    if (!off) return prev;

    off.start_time = start_time;
    off.end_time = end_time;

    return { ...prev, employees };
  });
}, []);



  const onResizeEnd = useCallback(
    async (id) => {
      const emp = payload.employees.find((e) => e.appointments.some((a) => a.id === id));
      if (!emp) {
        setEditingEventId(null);
        return;
      }
      const ap = emp.appointments.find((a) => a.id === id);
      if (!ap) {
        setEditingEventId(null);
        return;
      }

      await handleDrop({
        id,
        fromEmployeeId: emp.employee_id,
        toEmployeeId: emp.employee_id,
        start_time: ap.start_time,
        end_time: ap.end_time,
        date: formatDateLocal(activeDay),
        dragMode: true,
      });

      // wy≈ÇƒÖcz edycjƒô po zapisaniu
      setEditingEventId(null);
    },
    [payload, handleDrop, activeDay]
  );
  
  
  const onResizeEnd_TimeOff = useCallback(
  async (id) => {

    // ‚¨áÔ∏è LOKALNA FUNKCJA, DZIA≈ÅA TYLKO TUTAJ
    const fixDate = (value) => {
      if (!value) return "";
      if (typeof value === "string" && value.length === 10) return value;
      try {
        const d = new Date(value);
        return `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, "0")}-${String(
          d.getDate()
        ).padStart(2, "0")}`;
      } catch {
        return value;
      }
    };

    const emp = payload.employees.find((e) => e.time_off.some((t) => t.id === id));
    if (!emp) {
      resizing.current = false;
      return;
    }

    const off = emp.time_off.find((t) => t.id === id);
    if (!off) {
      resizing.current = false;
      return;
    }

    try {
      const token = await firebaseUser.getIdToken();

      const payloadToSend = {
        employee_id: emp.employee_id,
        date: fixDate(off.date), // ‚Üê DZIA≈ÅA TYLKO TU
        start_time: off.start_time,
        end_time: off.end_time,
        reason: off.reason || null,
      };

      await axios.put(
        `${backendBase}/api/schedule/time-off/${id}`,
        payloadToSend,
        { headers: { Authorization: `Bearer ${token}` } }
      );
    } catch (err) {
      console.error("‚ùå B≈ÇƒÖd zapisu time_off:", err.response?.data || err);
      alert(err.response?.data?.error || "B≈ÇƒÖd podczas zapisu blokady czasu.");
    }

    resizing.current = false;
  },
  [payload, firebaseUser, backendBase]
);




  /* ---------- resize start (pointer based) ---------- */
 const handleResizeStart = (item, direction, e, type = "appointment") => {
  e.stopPropagation();
  e.preventDefault();
 document.body.style.overflow = "hidden";
  const isAppointment = type === "appointment";
  const isTimeOff = type === "time_off";

  const startY = e.clientY || e.touches?.[0]?.clientY;
  const startMin = timeToMinutes(item.start_time);
  const endMin = timeToMinutes(item.end_time);

  const onMove = (ev) => {
    const y = ev.clientY || ev.touches?.[0]?.clientY;
    const deltaPx = y - startY;
    const minuteDeltaRaw = (deltaPx / HOUR_HEIGHT) * 60;
    const delta = Math.round(minuteDeltaRaw / 5) * 5;

    let newStart = startMin;
    let newEnd = endMin;

    if (direction === "top") {
      newStart = startMin + delta;
      if (newStart > endMin - 5) newStart = endMin - 5;
    } else {
      newEnd = endMin + delta;
      if (newEnd <= startMin + 5) newEnd = startMin + 5;
    }

    if (isAppointment) {
      onResizeLive({
        id: item.id,
        employee_id: item.employee_id,
        start_time: minutesToHHMM(newStart),
        end_time: minutesToHHMM(newEnd),
      });
    }

    if (isTimeOff) {
      onResizeLive_TimeOff({
        id: item.id,
        employee_id: item.employee_id,
        start_time: minutesToHHMM(newStart),
        end_time: minutesToHHMM(newEnd),
      });
    }
  };

  const onUp = () => {
    window.removeEventListener("pointermove", onMove);
    window.removeEventListener("pointerup", onUp);
  document.body.style.overflow = ""; // przywr√≥cenie scrolla

    if (isAppointment) onResizeEnd(item.id);
    if (isTimeOff) onResizeEnd_TimeOff(item.id);

    resizing.current = false;
  };

  window.addEventListener("pointermove", onMove, { passive: true });
  window.addEventListener("pointerup", onUp, { passive: true });
};




  /* ---------- UI helpers ---------- */
  const dayStripRef = useRef(null);

  useEffect(() => {
    const el = dayStripRef.current;
    if (el) {
      const activeEl = el.querySelector(".day-pill.active");
      if (activeEl) {
        const parent = el;
        const parentRect = parent.getBoundingClientRect();
        const childRect = activeEl.getBoundingClientRect();
        const offset = childRect.left - parentRect.left - parent.clientWidth / 2 + childRect.width / 2;
        parent.scrollBy({ left: offset, behavior: "smooth" });
      }
    }
  }, [activeDay]);

  const openAppointmentModal = (appointment) => {
    setSelectedAppointment(appointment);
    setModalOpen(true);
  };
  const handleModalUpdated = async () => {
    try {
      if (!firebaseUser) return;
      const token = await firebaseUser.getIdToken?.();
      const res = await axiosNoCache(`${backendBase}/api/calendar/shared`, {
        headers: { Authorization: `Bearer ${token}` },
        params: { date: formatDateLocal(activeDay) },
      });
      const normalized = {
        ...res.data,
        employees: res.data.employees.map((e) => ({
          ...e,
          day_off: Boolean(e.day_off || e.is_day_off),
          time_off: e.time_off ?? [],
          appointments: e.appointments ?? [],
        })),
      };
      setPayload(normalized);
    } catch (err) {
      console.error("‚ùå B≈ÇƒÖd od≈õwie≈ºenia po edycji:", err);
    }
  };

  /* ---------- render ---------- */
  return (
    <DndProvider backend={MultiBackend} options={HTML5toTouch}>
     <div
  className="calendar-root py-4 min-h-screen relative"
  style={{ width: "100vw", maxWidth: "100vw", overflowX: "hidden" }}

        onClick={() => {
          // klik w t≈Ço wy≈ÇƒÖcza tryb edycji
          setEditingEventId(null);
        }}
      >
        <style>{styles}</style>

        <div className="cal-header sticky top-0 bg-[#F9FAFB] pb-2 z-40">
          <div className="header-top flex items-center justify-center gap-4">
            <button
              onClick={() =>
                setActiveDay((prev) => {
                  const newDate = new Date(prev);
                  newDate.setMonth(prev.getMonth() - 1);
                  newDate.setDate(1);
                  return newDate;
                })
              }
              className="p-2 bg-white/60 hover:bg-white rounded-xl"
            >
              <ChevronLeft size={18} />
            </button>

            <div style={{ fontSize: 20, fontWeight: 700 }}>
              {activeDay.toLocaleDateString("pl-PL", { month: "long", year: "numeric" })}
            </div>

            <button
              onClick={() =>
                setActiveDay((prev) => {
                  const newDate = new Date(prev);
                  newDate.setMonth(prev.getMonth() + 1);
                  newDate.setDate(1);
                  return newDate;
                })
              }
              className="p-2 bg-white/60 hover:bg-white rounded-xl"
            >
              <ChevronRight size={18} />
            </button>
          </div>

          <div
            ref={dayStripRef}
            className="day-strip flex overflow-x-auto scrollbar-thin scrollbar-thumb-gray-300 mt-2 mb-1"
            style={{ scrollSnapType: "x mandatory", scrollBehavior: "smooth", padding: "8px 0" }}
          >
            {(() => {
              const year = activeDay.getFullYear();
              const month = activeDay.getMonth();
              const daysInMonth = new Date(year, month + 1, 0).getDate();
              return Array.from({ length: daysInMonth }).map((_, i) => {
                const mm = String(month + 1).padStart(2, "0");
                const dd = String(i + 1).padStart(2, "0");

                const d = new Date(`${year}-${mm}-${dd}T00:00:00`);

                const isActive = d.toDateString() === activeDay.toDateString();
                const dayName = weekDays[(d.getDay() + 6) % 7];
                return (
                  <div
                    key={i}
                    className={`day-pill ${isActive ? "active" : ""}`}
                    style={{ scrollSnapAlign: "center", flex: "0 0 auto" }}
                    onClick={(e) => {
                      e.stopPropagation();
                      setActiveDay(d);
                    }}
                  >
                    <div style={{ fontSize: 12 }}>{dayName}</div>
                    <div style={{ fontWeight: 700 }}>{d.getDate()}</div>
                  </div>
                );
              });
            })()}
          </div>
        </div>

        <div className="calendar-body">
          <div className="times-column" style={{ width: "20px", flex: "0 0 30px" }}>

            {(() => {
              const hoursCount = Math.ceil((calendarRange.dayEndMin - calendarRange.dayStartMin) / 60);
              return Array.from({ length: hoursCount + 1 }).map((_, i) => (
                <div key={i} style={{ height: HOUR_HEIGHT }} className="flex items-center">
                  {pad2(Math.floor(calendarRange.dayStartMin / 60) + i)}:00
                </div>
              ));
            })()}
          </div>

         <div
  className="columns-wrap flex gap-3 overflow-x-auto scroll-smooth scrollbar-thin scrollbar-thumb-gray-300"
  style={{ width: "100%", gap: "0px" }}
>

  

            {payload.employees
              .filter(emp => emp.is_active)
              .map((emp) => (
<div
  key={emp.employee_id}
  className="employee-col"
  style={{
    flex: (() => {
      const activeCount = payload.employees.filter(e => e.is_active).length;

      // 1 pracownik = 100%
      if (activeCount === 1) return "0 0 100%";

      // 2+ pracownik√≥w = zawsze 50%
      return "0 0 50%";
    })(),
    scrollSnapAlign: "start",
  }}
>

                  <div className="employee-header">
                    <img
                      src={emp.employee_image_url ? `${backendBase}/${emp.employee_image_url}` : "/static/placeholder-avatar.png"}
                      alt={emp.employee_name}
                      className="avatar"
                      onError={(e) => {
                        e.currentTarget.src = "/static/placeholder-avatar.png";
                      }}
                    />

                    <div>
                      <div
                        style={{ fontWeight: 700, cursor: "pointer", textDecoration: "underline" }}
                        onClick={() => navigate(`/employee/${emp.employee_id}/calendar-month`)}
                      >
                        {emp.employee_name}
                      </div>

                      {emp.day_off ? (
                        <div className="work-hours" style={{ color: "#EF4444", fontWeight: 600 }}>
                          üí§ Dzie≈Ñ wolny
                        </div>
                      ) : (
                        <div className="work-hours">
                          {formatHHMM(emp.working_hours?.open)} - {formatHHMM(emp.working_hours?.close)}
                        </div>
                      )}
                    </div>
                  </div>


                  <DroppableTimeGrid
                    employee={emp}
                    onDrop={handleDrop}
                    currentDate={activeDay}
                    dayStartMin={calendarRange.dayStartMin}
                    dayEndMin={calendarRange.dayEndMin}
                    HOUR_HEIGHT={calendarRange.HOUR_HEIGHT}
                  >
                    <div
                      className="time-grid"
                      style={{
                        position: "relative",
                        padding: "0 6px",
                        height: `${((calendarRange.dayEndMin - calendarRange.dayStartMin) / 60) * HOUR_HEIGHT}px`,
                        background: "transparent",
                      }}
                      onClick={(e) => {
                        e.stopPropagation();
                        // klik w grid wy≈ÇƒÖcza edycjƒô
                        setEditingEventId(null);
                      }}
                    >

                      {/* time_off render */}
                      {console.log("TIME OFF RAW FOR EMP:", emp.employee_id, emp.time_off)}
                      {emp.time_off &&
                        emp.time_off.map((off, i) => {
                          const offDate = off.date || formatDateLocal(activeDay);
                          const endIso = `${offDate}T${(off.end_time || "00:00")}:00`;
                          const startIso = `${offDate}T${(off.start_time || "00:00")}:00`;

                          const endDt = new Date(endIso);
                          const startDt = new Date(startIso);
                          const now = new Date();

                          const isExpired = endDt.getTime() <= now.getTime();

                          const start = timeToMinutes(off.start_time);
                          const end = timeToMinutes(off.end_time);
                          const topPx = ((start - calendarRange.dayStartMin) / 60) * HOUR_HEIGHT;
                          const heightPx = ((end - start) / 60) * HOUR_HEIGHT;

                          return (
  <div
    key={`off-${off.id ?? i}`}
    className="timeoff-block"
    style={{
      position: "absolute",
      top: `${topPx}px`,
      left: "4px",
      right: "4px",
      height: `${heightPx}px`,
      background: "rgba(0,0,0,0.06)",
      borderRadius: 12,
      padding: "6px 8px",
      zIndex: 5,
      cursor: "pointer",
	  touchAction: editingEventId === `off-${off.id}` ? "none" : "pan-y",

      userSelect: "none",
    }}
    onClick={(e) => {
      e.stopPropagation();

      // je≈õli blokada w trybie edycji -> klik KO≈ÉCZY tryb edycji
      if (editingEventId === `off-${off.id}`) {
        setEditingEventId(null);
        return;
      }

      // normalne klikniƒôcie -> otwiera modal
      setSelectedTimeOff({
        ...off,
        id: Number(off.id),
        employee_id: emp.employee_id,
        date: off.date ?? formatDateLocal(activeDay),
        start_time: off.start_time,
        end_time: off.end_time,
        reason: off.reason ?? "",
      });
      setTimeOffModalOpen(true);
    }}

    // przytrzymanie ‚Äì wej≈õcie do trybu edycji
    onPointerDown={(e) => {
      e.stopPropagation();
      pointerDownTime.current = performance.now();

      holdTimeout.current = setTimeout(() => {
        setEditingEventId(`off-${off.id}`);   // ‚Üê TRYB EDYCJI BLOKADY
      }, 250);
    }}

    onPointerUp={() => {
      clearTimeout(holdTimeout.current);
    }}

    onPointerMove={(e) => {
      if (Math.abs(e.movementX) > 4 || Math.abs(e.movementY) > 4) {
        clearTimeout(holdTimeout.current);
      }
    }}
  >
    {/* --- TRYB EDYCJI ‚Äî STRZA≈ÅKI --- */}
    {editingEventId === `off-${off.id}` && (
      <>
        {/* TOP HANDLE */}
        <div
          data-resize-handle="top"
          onPointerDown={(e) => {
            e.stopPropagation();
            resizing.current = true;
            handleResizeStart(
              { ...off, employee_id: emp.employee_id, id: off.id },
              "top",
              e,
              "time_off"
            );
          }}
          onPointerUp={() => (resizing.current = false)}
          style={{
            position: "absolute",
            top: -10,
            left: "50%",
            transform: "translateX(-50%)",
            width: 26,
            height: 16,
            background: "#fff",
            border: "2px solid #E55B10",
            borderRadius: 6,
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            cursor: "ns-resize",
            zIndex: 20,
            fontSize: 10,
            fontWeight: 700,
          }}
        >
          ‚ñ≤
        </div>

        {/* BOTTOM HANDLE */}
        <div
          data-resize-handle="bottom"
          onPointerDown={(e) => {
            e.stopPropagation();
            resizing.current = true;
            handleResizeStart(
              { ...off, employee_id: emp.employee_id, id: off.id },
              "bottom",
              e,
              "time_off"
            );
          }}
          onPointerUp={() => (resizing.current = false)}
          style={{
            position: "absolute",
            bottom: -10,
            left: "50%",
            transform: "translateX(-50%)",
            width: 26,
            height: 16,
            background: "#fff",
            border: "2px solid #E55B10",
            borderRadius: 6,
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            cursor: "ns-resize",
            zIndex: 20,
            fontSize: 10,
            fontWeight: 700,
          }}
        >
          ‚ñº
        </div>

        {/* RAMKA EDYCJI */}
        <div
          style={{
            position: "absolute",
            inset: 0,
            border: "2px dashed #E55B10",
            borderRadius: 12,
            pointerEvents: "none",
            zIndex: 15,
          }}
        />
      </>
    )}

    {/* --- TRE≈öƒÜ BLOKADY CZASU --- */}
    <div style={{ fontWeight: 700 }}>üîí Blokada czasu</div>
    <div style={{ fontWeight: 600, fontSize: 13 }}>
      {formatTime(off.start_time)} ‚Äì {formatTime(off.end_time)}
    </div>
    <div style={{ fontSize: 12, opacity: 0.85 }}>
      {off.reason || "Brak powodu"}
    </div>
  </div>
);


                        })}

                      {/* appointments render with clusters */}
                      {(() => {
                        const items = (emp.appointments || [])
                          .filter(a => a.status !== "cancelled")
                          .map(a => ({
                            ...a,
                            start: timeToMinutes(a.start_time),
                            end: timeToMinutes(a.end_time),
                            top: ((timeToMinutes(a.start_time) - calendarRange.dayStartMin) / 60) * HOUR_HEIGHT,
                            height: ((timeToMinutes(a.end_time) - timeToMinutes(a.start_time)) / 60) * HOUR_HEIGHT
                          }))
                          .sort((a, b) => a.start - b.start);

                        const clusters = [];

                        items.forEach(ev => {
                          let added = false;

                          for (let cluster of clusters) {
                            const overlaps = cluster.some(
                              c => !(ev.end <= c.start || ev.start >= c.end)
                            );
                            if (overlaps) {
                              cluster.push(ev);
                              added = true;
                              break;
                            }
                          }

                          if (!added) clusters.push([ev]);
                        });

                        const render = [];

                        clusters.forEach(cluster => {
                          const cols = [];

                          cluster.forEach(ev => {
                            let placed = false;

                            for (let col of cols) {
                              const last = col[col.length - 1];
                              if (last.end <= ev.start) {
                                col.push(ev);
                                placed = true;
                                break;
                              }
                            }

                            if (!placed) cols.push([ev]);
                          });

                          const totalCols = cols.length;

                          cols.forEach((col, colIndex) => {
                            const widthPercent = 100 / totalCols;
                            const leftPercent = (100 / totalCols) * colIndex;

                            col.forEach(a => {
                              render.push(
                               
							   
							   
							   
							   <DraggableEvent
  key={a.id}
  appointment={{ ...a, employee_id: emp.employee_id }}
  isEditing={editingEventId === a.id}
  resizing={resizing}
  onSelect={(appt) => {
    if (editingEventId === a.id) {
      setEditingEventId(null);
      return;
    }
    setSelectedAppointment(a);
    setModalOpen(true);
  }}
  onEnterEditMode={(id) => setEditingEventId(id)}
>
  <div
    style={{
      position: "absolute",
      top: `${a.top}px`,
      height: `${a.height}px`,
      left: `calc(${leftPercent}% + 6px)`,
      width: `calc(${widthPercent}% - 10px)`,
      zIndex: 20 + colIndex,
      pointerEvents: "none", // <-- wa≈ºne
    }}
  >

    {/* --- HANDLE TOP --- */}
    {editingEventId === a.id && (
      <div
        data-resize-handle="top"
        onPointerDown={(e) => {
          e.stopPropagation();
          resizing.current = true;
          handleResizeStart(a, "top", e, "appointment");
        }}
        style={{
          position: "absolute",
          top: -12,
          left: "50%",
          transform: "translateX(-50%)",
          width: 26,
          height: 18,
          background: "#fff",
          border: "2px solid #E55B10",
          borderRadius: 6,
          cursor: "ns-resize",
          zIndex: 999,
          pointerEvents: "all",
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
        }}
      >
        <div
          style={{
            width: 0,
            height: 0,
            borderLeft: "6px solid transparent",
            borderRight: "6px solid transparent",
            borderBottom: "8px solid #E55B10",
          }}
        />
      </div>
    )}

    {/* --- HANDLE BOTTOM --- */}
    {editingEventId === a.id && (
      <div
        data-resize-handle="bottom"
        onPointerDown={(e) => {
          e.stopPropagation();
          resizing.current = true;
          handleResizeStart(a, "bottom", e, "appointment");
        }}
        style={{
          position: "absolute",
          bottom: -12,
          left: "50%",
          transform: "translateX(-50%)",
          width: 26,
          height: 18,
          background: "#fff",
          border: "2px solid #E55B10",
          borderRadius: 6,
          cursor: "ns-resize",
          zIndex: 999,
          pointerEvents: "all",
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
        }}
      >
        <div
          style={{
            width: 0,
            height: 0,
            borderLeft: "6px solid transparent",
            borderRight: "6px solid transparent",
            borderTop: "8px solid #E55B10",
          }}
        />
      </div>
    )}

    {/* --- EVENT-CARD -> w ≈õrodku nic nie zmieniasz --- */}
    <div
      className="event-card"
      style={{
        position: "absolute",
        inset: 0,
        background: stringToPastelColor(a.service_name),
		opacity: 0.85,    // üëà DODANE
        borderRadius: "14px",
        padding: a.height < 40 ? "2px 4px" : "2px 10px",
        userSelect: "none",
        overflow: "hidden",
        pointerEvents: "all", // <-- wa≈ºne
        cursor: "pointer",
      }}
      onClick={(e) => {
        e.stopPropagation();
        if (editingEventId === a.id) {
          setEditingEventId(null);
          return;
        }
        setSelectedAppointment(a);
        setModalOpen(true);
      }}
    >
      {/* tre≈õƒá eventu */}
      <div className="event-card-content">
        <div style={{ fontSize: a.height < 40 ? 10 : 10, fontWeight: 600 }}>
          {formatHHMM(a.start_time)} - {formatHHMM(a.end_time)}
        </div>
        <div style={{ fontSize: a.height < 40 ? 10 : 10, fontWeight: 600 }}>
          {a.client_name}
        </div>

        {a.height < 30 ? (
          <div style={{
            fontSize: 9,
            opacity: 0.85,
            whiteSpace: "nowrap",
            overflow: "hidden",
            textOverflow: "ellipsis",
          }}>
            {a.service_name}
          </div>
        ) : (
          <div style={{ fontSize: 10, opacity: 0.8 }}>
            {a.service_name}
            {a.addons && <> + {a.addons}</>}
          </div>
        )}
      </div>
    </div>

    {/* --- BORDER EDYCJI --- */}
    {editingEventId === a.id && (
      <div
        style={{
          position: "absolute",
          inset: 0,
          border: "2px dashed #E55B10",
          borderRadius: 14,
          pointerEvents: "none",
          zIndex: 998,
        }}
      />
    )}
  </div>
</DraggableEvent>

							   
							   
							   
							   

                              );
                            });
                          });
                        });

                        return render;
                      })()}
                    </div>
                  </DroppableTimeGrid>
                </div>
              ))}
          </div>
        </div>

        <div className="floating-add" onClick={() => alert("Dodaj wizytƒô (DEMO)")}>
          <Plus size={28} color="white" />
        </div>
      </div>

      {conflictModal.visible && (
        <div
          style={{
            position: "fixed",
            inset: 0,
            background: "rgba(0,0,0,0.4)",
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            zIndex: 999,
          }}
        >
          <div
            style={{
              background: "white",
              borderRadius: 12,
              padding: 24,
              width: 320,
              textAlign: "center",
              boxShadow: "0 10px 30px rgba(0,0,0,0.2)",
            }}
          >
            <h3 style={{ fontWeight: 700, marginBottom: 10 }}>‚ö†Ô∏è Kolizja wizyt</h3>
            <p style={{ fontSize: 14, marginBottom: 10 }}>Ta wizyta nak≈Çada siƒô z innƒÖ wizytƒÖ tego pracownika.</p>
            <p style={{ fontSize: 13, color: "#555" }}>Czy chcesz mimo to zapisaƒá zmianƒô?</p>

            <div style={{ display: "flex", justifyContent: "center", gap: 12, marginTop: 20 }}>
              <button
                onClick={() => setConflictModal({ visible: false, retryAction: null })}
                style={{
                  background: "#e5e7eb",
                  padding: "6px 14px",
                  borderRadius: 8,
                  fontWeight: 600,
                }}
              >
                Anuluj
              </button>
              <button
                onClick={() => conflictModal.retryAction?.()}
                style={{
                  background: "#ef4444",
                  color: "white",
                  padding: "6px 14px",
                  borderRadius: 8,
                  fontWeight: 600,
                }}
              >
                Zapisz mimo kolizji
              </button>
            </div>
          </div>
        </div>
      )}

      {timeOffModalOpen && selectedTimeOff && (
        <TimeOffModal
          open={timeOffModalOpen}
          onClose={() => setTimeOffModalOpen(false)}
          timeOff={selectedTimeOff}
          onUpdated={async () => {
            setTimeOffModalOpen(false);
            await handleModalUpdated();
          }}
        />
      )}

      {modalOpen && selectedAppointment && (
        <AppointmentModal
          open={modalOpen}
          onClose={() => setModalOpen(false)}
          appointmentId={selectedAppointment.id}
          onUpdated={async () => {
            setModalOpen(false);
            await handleModalUpdated();
          }}
          socket={socket}
        />
      )}
    </DndProvider>
  );
}
